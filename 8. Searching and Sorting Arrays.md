**Class**: [[CSC-121]]
**Date**: 2025-10-13
**Topics**: #algorithms #searching #sorting #data

- **8.1 Focus on Software Engineering: Introduction to Search Algorithms**
	- *Concept*: A search algorithm is a method of locating a specific item in a larger collection of data. This section discusses two algorithms for searching the contents of an array
	- *The Linear Search*
		- *linear search*: #vocab 
			- A search algorithm that uses a loop to sequentially step through an array's elements
		- linear / sequential search is a very simple algorithm
		- starts at first element
		- compares each element with the target
		- returns when target is found *OR* end of the array
		- *example in C++*: [[#8.1.1]]
		- -1 is returned if search is *unsuccessful* 
	- *Inefficiency of Linear Search*
		- Advantage = its simplicity
			- Easy to understand
			- Easy to implement
			- Does not require the data to be moved or restored
			- Does not require the data to be in a specific order
		- Disadvantage = Inefficient!!
			- If the array has 20,000 elements, it may need to look through 20,000 elements in order to find the target
			- On average it makes *N/2 comparisons* 
			- 50,000 elements, Avg case = 25,000 comparisons
			- *Average* = N/2, *Max* = N
		- Should not be used on large arrays
	- *The Binary Search*
		- *Binary Search*: #vocab 
			- A search algorithm that works by repeatedly slicing in half the part of array to be searched 
		- Much more efficient than Linear search
		- It does **require** the array to be **sorted**
		- Starts with middle element
		- If element is *equal to* the target, return
		- if element is *greater than* the target
			- split array in half
			- repeat on the lower half
		- If element is *less than* the target
			- split array in half
			- repeat on upper half
		- In both cases, half of the elements are removed from searching with each search
		- *example in C++*: [[#8.1.2]]
		- Algorithm uses 3 index variables
			- first
			- last
			- middle
		- *first* and *last* mark the *boundaries* of the **portion** of the array being searched
		- Initialized with the subscript of the array's first and last elements
		- the element midway is calculated and set to the middle variable
		- if the element at the *middle* index does not equal the target
			- first *OR* last is set to the *middle* value
			- adjusted so that the **top** or **bottom** half are searched
	- *The Efficiency of Binary Search*
		- MUCH more efficient than linear
		- cuts searched elements in half each iteration
		- with 1000 elements, there are max 10 iterations
- **8.2 Focus on Problem Solving and Program Design: A Case Study**
- **8.3 Focus on Software Engineering: Introduction to Sorting Algorithms**
- **8.4 Focus on Problem Solving and Program Design: A Case Study**
- **8.5 Sorting and Searching vectors**

### 8.1.1
**Linear Search**
```c++
int linearSearch (const int arr[], int size, int target)
	bool found = false; // flag to indicate if value is found
	int position = -1; // to record the position of the search value
	int index = 0; // sunbscript to search the array
	
	while(index < size && !found)
	{
		if (array[index] == target) // If the value is found
		{
			found = true; // set flag to true
			position = index; // update position to current index
		}
		index++; // go to the next element
	}
	return position; // returns position or -1
```

### 8.1.2
**Binary Search**
```c++
int binarySeach(const int array[], int numElements, int target)
{
	int first = 0, // First array Element
		last = numElements - 1; // last array element
		middle, // Midpoint for search
		position = -1; // Position of search value
		
	bool found = false; // Flag
	
	while (!found && first <= last)
	{
		middle = (first + last) / 2; // Calculate midpoint
		if (array[middle] == target) // if target is found
		{
			found = true;
			position = middle;
		}
		
		else if (array[middle] > value) // if value is in lower half
			last = middle - 1;
		else
			first = middle + 1; // if value is in upper half
	}
	return position;
}
```