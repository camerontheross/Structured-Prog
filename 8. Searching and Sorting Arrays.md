**Class**: [[CSC-121]]
**Date**: 2025-10-13
**Topics**: #algorithms #searching #sorting #data

- **8.1 Focus on Software Engineering: Introduction to Search Algorithms**
	- *Concept*: A search algorithm is a method of locating a specific item in a larger collection of data. This section discusses two algorithms for searching the contents of an array
	- *The Linear Search*
		- *linear search*: #vocab 
			- A search algorithm that uses a loop to sequentially step through an array's elements
		- linear / sequential search is a very simple algorithm
		- starts at first element
		- compares each element with the target
		- returns when target is found *OR* end of the array
		- *example in C++*: [[#8.1.1]]
		- -1 is returned if search is *unsuccessful* 
	- *Inefficiency of Linear Search*
		- Advantage = its simplicity
			- Easy to understand
			- Easy to implement
			- Does not require the data to be moved or restored
			- Does not require the data to be in a specific order
		- Disadvantage = Inefficient!!
			- If the array has 20,000 elements, it may need to look through 20,000 elements in order to find the target
			- On average it makes *N/2 comparisons* 
			- 50,000 elements, Avg case = 25,000 comparisons
			- *Average* = N/2, *Max* = N
		- Should not be used on large arrays
	- *The Binary Search*
		- *Binary Search*: #vocab 
			- A search algorithm that works by repeatedly slicing in half the part of array to be searched 
		- Much more efficient than Linear search
		- It does **require** the array to be **sorted**
		- Starts with middle element
		- If element is *equal to* the target, return
		- if element is *greater than* the target
			- split array in half
			- repeat on the lower half
		- If element is *less than* the target
			- split array in half
			- repeat on upper half
		- In both cases, half of the elements are removed from searching with each search
		- *example in C++*: [[#8.1.2]]
		- Algorithm uses 3 index variables
			- first
			- last
			- middle
		- *first* and *last* mark the *boundaries* of the **portion** of the array being searched
		- Initialized with the subscript of the array's first and last elements
		- the element midway is calculated and set to the middle variable
		- if the element at the *middle* index does not equal the target
			- first *OR* last is set to the *middle* value
			- adjusted so that the **top** or **bottom** half are searched
	- *The Efficiency of Binary Search*
		- MUCH more efficient than linear
		- cuts searched elements in half each iteration
		- with 1000 elements, there are max 10 iterations
	- ![Binary Vs Linear Search Animated Gifs](https://blog.penjee.com/wp-content/uploads/2015/04/binary-and-linear-search-animations.gif)
- **8.2 Focus on Problem Solving and Program Design: A Case Study**
- **8.3 Focus on Software Engineering: Introduction to Sorting Algorithms**
	- *Concept*: Sorting Algorithms are used to arrange data into some order
	- *Sorting Algorithms*
		- Many tasks require data to be sorted in some order
			- Customer lists - Alphabetical
			- Student Grades - From high to low
			- Product codes - sorted by how similar products are
		- *ascending order* - lowest to highest
		- *descending order* - highest to lowest
	- *Bubble Sort*
		- ![Bubble Sort | Brilliant Math & Science Wiki](https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)
		- can arrange in ascending OR descending
		- *Bubble sort*: #vocab 
			- A sorting algorithm that causes certain values to "bubble" towards each end of the array with each pass
		- *Example in C++*: [[#8.3.1]]
		- uses two nested for loops
		- uses *swap* to switch elements when one is greater than the next (ascending)
		- *Example in C++*: [[#8.3.2]]
		- bubble sort is *simple* yet *inefficient*
	- *Selection Sort*
		- *Selection Sort*: #vocab 
			- A sorting algorithm that steps through an array moving each value to its *final position*
		- fewer swaps since each element is put into it's final position in the array
		- ![Insertion Sort, Selection Sort, and Bubble Sort | by Sharad ...](https://miro.medium.com/1*5WXRN62ddiM_Gcf4GDdCZg.gif)
		- *Example in C++*: [[#8.3.3]]
- **8.4 Focus on Problem Solving and Program Design: A Case Study**
- **8.5 Sorting and Searching vectors**
	- *Concept*: The sorting and searching algorithms in this chapter can be applied to **vectors** and **arrays**
	- Vectors are easy to drag and drop into these algorithms 
	- Works the same, different syntax
	- 

### 8.1.1
**Linear Search**
```c++
int linearSearch (const int arr[], int size, int target)
	bool found = false; // flag to indicate if value is found
	int position = -1; // to record the position of the search value
	int index = 0; // sunbscript to search the array
	
	while(index < size && !found)
	{
		if (array[index] == target) // If the value is found
		{
			found = true; // set flag to true
			position = index; // update position to current index
		}
		index++; // go to the next element
	}
	return position; // returns position or -1
```

### 8.1.2
**Binary Search**
```c++
int binarySeach(const int array[], int numElements, int target)
{
	int first = 0, // First array Element
		last = numElements - 1; // last array element
		middle, // Midpoint for search
		position = -1; // Position of search value
		
	bool found = false; // Flag
	
	while (!found && first <= last)
	{
		middle = (first + last) / 2; // Calculate midpoint
		if (array[middle] == target) // if target is found
		{
			found = true;
			position = middle;
		}
		
		else if (array[middle] > target) // if value is in lower half
			last = middle - 1;
		else
			first = middle + 1; // if value is in upper half
	}
	return position;
}
```

### 8.3.1
*Bubble Sort*
```c++
void bubbleSort(int array[], int size)
{
	// holds subscript for last element that needs to be compared with neighbor
	int maxElement;
	// array subscript
	int index;
	
	// iterates once per element in array
	// causes max element to take on all array subscripts
	// from highest subscript to 0
	for (max element = size - 1; maxElement > 0; maxElement--)
	{
		// iterates once per unsorted element
		// starts at 0 and increments up thru maxElement - 1 
		for (index = 0; index < maxElement; index++)
		{
			// if current element is greater than next element
			if (array[index] > array[index + 1])
			{
				// swap elements
				// current element = next 
				// next = current
				swap(array[index], array[index + 1]);
			}
		}
	}
}
```

### 8.3.2
*Swapping in C++*
```c++
// passed pointers to variables that need to be swapped
// crucial as we need to change the values stored in variables a and b
void swap(int &a, int &b)
{
	// temporarily stores a
	int temp = a;
	// a is now = to b
	a = b;
	// set b to former a value (stored in temp)
	b = temp;
}
```

### 8.3.3
*Selection sort in C++*
```c++
void selectionSort(int array[], int size)
{
	int minIndex, minValue;
	
	// starts at the first index
	// represents the start of the portion	
	for int(start = 0; start < (size - 1); start++)
	{
		minIndex = start;
		minValue = array[start];
		
		// starts at value after the beginning of the portion
		for (int index = start + 1; index < size; index++)
		{
			if (array[index] < minValue)
			{
				minValue = array[index];
				minIndex = index;
			}
		}
		swap(array[minIndex], array[start]);
	}
}
```