**Class**: [[CSC-121]]
**Date**: 2025-09-15
**Topics**: #conditionals 

# Reading
- **4.1 Relational Operators**
	- *Concept*: Relational operators allow you to compare numeric and char values to determine whether one is greater than. less than, equal to or not equal to another
	- So far the programs have followed this simple scheme:
		- gather input from the user
		- Perform one or more calculations
		- Display the results on the screen
	- Computers are good at performing calculations but they are also adept at comparing values to determine whether one is >, < == , or !=
	- These operations are valuable for tasks such as examining sales figures, determining profit and loss, checking a number to ensure it is within an acceptable range , and input validation
	- **Relational operators**:
		- Greater than: >
		- Less than: <
		- Greater than or equal to: >=
		- Less than or equal to: <=
		- Equal to: ==
		- Not equal to: !=
	- All of the relational operators are binary (use two operands)
	- x < y 
	- *Relational Expression*: #vocab 
		- an expression that uses a relational operator to test one value against another
	- *The value of a Relationship*
		- All expressions have a value
		- Relational expressions have a *boolean value*
			- true or false
		- a == 4
			- if the value of a is 4 the expression is *true*
			- if the value of a is NOT 4 the expression is *false*
	- *What is Truth?*
		- How does a computer store *True* and *False* in memory?
			- 1 for true
			- 0 for false
		- Relational expressions have a higher precedence than the assignment operator
			- this means they are evaluated first by the computer
- **4.2 The _if_ Statement**
	- *Concept*: The _if_ statement can cause other statements to execute only under certain conditions
	- *sequence structure*: #vocab 
		- a set of programming instructions that are executed in sequence
	- programs often need more than one path of execution
	- many algorithms require a program to exeute some statements only under certain circumstance
	- this can be accomplished with a *decision structure*: #vocab 
		- A set of programming statements where an action is taken only when a certain condition is met
	- In a decision structure, a specific action is taken when a condition exists. The action is not performed when the condition does not exist
	- ![[Screenshot 2025-09-15 at 1.04.24 PM.png]]
	- in the flowchart, the action "Wear a coat" is only performed if the condition "cold outside" is true
	- the action is *conditionally executed*: #vocab 
		- a statement that is executed only when a certain condition exists
	- one way to code a decision structure in C++ is with the if statement
		- if (expression)
			- statement;
	- the if statement is simple in how it works
	- if the value of the expression inside the parentheses is true, the next statement is executed
	- *Be careful with semicolons*
		- Semicolons do not mark the end of a line, but the end of a complete C++ statement
		- The _if_ statement isn't complete without the conditionally executed statement that comes after it
		- do NOT put a semicolon after the if (expression) portion
		- if there is a semicolon after the if, the compiler will assume you are placing a null statement
		- *null statement*: #vocab 
			- an empty statement that does nothing
		- This will prematurely terminate the if statement
		- This leads to the conditionally executed code always executing
	- *Programming Style and the if Statement*
		- Even though if statements usually span more than one line, they are technically one long statement
		- if (a >= 100) 
			- cout << "foo" ;
		- if (a >= 100) cout << "foo";
			- this is valid
		- in both examples the compiler considers the if part and the cout statement as one unit
		- Indentation and spacing are just for human reading
		- Here are important style rules
			- The *conditionally executed* statement should appear on the line after the *if*
			- The *conditionally executed* statement should be indented one "level" left from the *if* statement
		- By indenting the conditionally executed statement, you are causing it to stand out visually
		- This is so you can tell at a glance what part of the program the if statement executes
	- *Comparing Floating-Point Numbers*
		- Because of the way floating point numbers are stored in memory, rounding errors sometimes occur
		- This is because some fractional numbers cannot be exactly represented using binary
		- Be careful when using the equality ( == ) operator to compare floats
		- The example is
			- a = 1.5000000001
			- b = 1.5
			- the == comparison returns true
		- to prevent round off errors you should stick to greater-than and less-than comparisons with floats
	- *And now back to Truth*
		- Now that you've gotten your feet wet with relational expressions and _if statements_ let's look at the subject of truth again
		- You have seen that a relational expression has the value 1 when true and 0 when false
		- in the world of if statements the concept of truth is expanded
			- 0 is still false
			- everything else is true
		- any value besides 0, even negative values, represents true
		- Just as in real life, truth is a complicated thing
		- *summary of the rules*
			- When a *relational expression* is *true*, its value is 1
			- When a *relational expression* is *false* , its value is 0
			- Any expression that has the value 0 is considered *false* by the *if statement*. This included the *bool* value *false*, which is equivalent to 0
			- Any expression that has a value other than 0 is considered *true* by this *if statement*. This includes the *bool* value *true* which is equivalent to 1
		- The fact that the *if statement* consideres any nonzero value as true opens many possibilities
		- relational expressions are not the only conditions that may be tested
		- EX:
			- if(value)
				- cout << "It is True!";
		- the *if statement* above does not test a relational expression, but rather the ontents of a variable
		- If the variable contains any number other than 0, the *conditional expression* executes
		- expanded in *Chapter 6*
	- *Don't confuse == with =*
		- == compares values
		- = assigns a value
- **4.3 Expanding the _if_ Statement**
	- *Concept*: The _if_ statement can conditionally execute a block of statements enclosed in braces
	- What if you want to conditionally execute many statements, not just one line
	- enclose statements in braces { }
	- Enclosing a group of statements inside a set of braces creates a *block*: #vocab 
		- a group of statement enclosed inside of *braces*
	- any time your program has a block of code, it should be indented
	- The if statement will execute the block in the order they appear
	- *Don't forget the braces!*
		- if you intend to conditionally execute a block of statements with an if statement, don't forget the braces
		- without the braces the if statement will only execute the next line
- **4.4 The _if / else_ Statement**
	- *Concept*: The if/else statement will execute one group of statements if the expression is true, and another if the expression is false
	- *if / else* is an expansion of the *if* statement
	- if (expression)
		- statement or block
	- else
		- statement or block
	- as with the if statement, an expression is evaluated
	- if it is *true* a statement or block is executed
	- if it is *false* a *separate* statement or block is executed
	- **![[Screenshot 2025-09-15 at 2.20.25 PM.png]]
	- Else is at the same level of indentation as if
	- the statement whose execution is controlled by else is indented one level
	- division by zero is not possible, and will prematurely exit code
	- below is an example of code that checks the divisor for zero
- **4.5 Nesting _if_ Statements
	- *Concept*: To test more than one condition, an if statement can be nested inside another _if_ statement
	- sometimes an if statement must be inside of another if statement
	- ![[Screenshot 2025-09-15 at 3.51.49 PM.png]]
	- If we follow the flow we see that the expression (employed == 'Y)' is tested
	- If the expression is *false* there is no need to perform further tests
	- if the expression is *true* we test a second condition
	- this is done with a nested decision structure that tests the expression (recentGrad = 'Y)
	- If this *expression* is *true* then the customer qualifies for the special interest rate
	- if this *expression* is *false* then the customer does not
	- *Programming Style and Nested Decision Structures*
		- for *readability* and *easier debugging* it is important to use proper alignment and indentation in a set of nested *if statements* 
		- This makes it *easier to see* which *actions are performed* by each part of the decision structure
- **4.6 The if / else if statement
	- *Concept*: The *if / else if* statement tests a series of conditions. It is often simpler to test a series of conditions with the *if / else if* statement than with a set of nested *if / else* statements
	- the *if / else if* statement makes certain types of nested decision logic simpler to write
	- Format:
		- if (expression_1)
			- statement
		- else if (expression_2)
			- statement
		- else
			- statement
	- when the statement executes, expression 1 is tested
	- if expression 1 is true the immediate statement/block is executed
	- rest of structure is ignored
	- if it is false do the same with next expression
	- continue until *else* is reached
	- *trailing else*: #vocab
		- the last *else* clause which does not have an *if* statement following it in an *if / else* construct
	- *Using the Trailing else to Catch Errors*
		- The trailing *else* clause, which appeats at the end of the *if / else if* statement, is optional
		- Often used to catch errors
		- Example will assign a grade to any number entered as the test score, including negative numbers
		- If a negative test is entered the user has probably made a mistake
		- see bottom
	- *The if / else if statement compared to a Nested Decision Structure*
		- You never have to use the *if / if else* statement because its logic can be coded with nested *if / else* statements
		- A long series of nested *if / else* statements has two particular disadvantages when debugging 
			- The code can grow *complex* and become *difficult to understand*
			- because *indenting is important* in nested statements, a long series of nested *if / else* statements can become too long to be displayed on the computer screen without horizontal scrolling. Long statements also tend to *wrap around* when printed on paper, making the code even more difficult to read
		- The logic of an *if / else if* statement is usually easier to follow than that of a long series of nested *if / else* statements
- **4.7 The _if_ Statement with Initialization**
	- *Concept*: Beginning with C++17, an *if statement* can optionally have an *initialization clause*
	- If you are using C++ 17 or later, you can write an *if statement* with an *optional initialization clause* that is executed *before* the *conditional expression* is *evaluated*
	- format:
		- if (initialization; expression)
			- statement;
	- Example:
		- if (int len = password.length(); len < MIN_LENGHT)
			- cout << "Password too short";
	- in the example the *initialization clause* defines an int variable named len and assigns the length of the password object to it
	- then the conditional expression len < MIN_LENGTH is evaluated
	- when a variable is defined in the *initialization clause* of an if statement, the variables *scope* is limited to the *if statement* and it's *else block* 
- **4.8 Flags**
	- *Concept*: A flag is a *Boolean* or *integer*  variable that signals when a condition exits
	- *flag*: #vocab 
		- typically a *bool* variable that signals when some condition exits in the program
	- When the *flag* variable is set to *false* it indicates that the condition *does not exist* 
	- When the *flag* variable is set to *true* it indicates that the condition *does exist*
	- EX:
		- program calculates  sales commissions
		- has the bool (bool salesQuotaMet = false)
		- in the program the *salesQuotaMet* variable is used as a *flag* to indicate whether a salesperson has met their sales quota
		- Variable is *initialized* with the value *false* since we do not yet know if the salesperson has met the sales quota
		- Assuming a variable named sales holds the amount of sales, code similar to the following might be used to set the value of salesQuotaMet
			- if (sales >= QUOTA_AMOUNT)
				- salesQuotaMet = true
			- else
				- salesQuotaMet = false
		- As a result we can use the salesQuotaMet variable as a *flag* to indicate whether the sales quota has been met
		- later in the program we might test the flag:
			- if (salesQuotaMet)
				- cout << "You have met your sales quota!\n";
	- *Integer Flags*
		- *Integer* variables may also be used as *flags*
		- This is because C++ uses 0 as false
		- example is the same as the previous, but 1 is used as true and 0 as false
- **4.9 Logical Operators**
	- *Concept*: Logical operators connect two or more relational expressions into one or reverse the logic of an expression
	- In the previous section you saw how a program tests two conditions with two if statements
	- in this section you will see how to use logical operators to combine two or more relational expressions into one
	- *C++ logical operators*:
		- *&&* represents AND
		- *||* represets OR
		- *!* represents NOT
	- *The && Operator*
		- The && operator is known as the logical AND operator
		- takes two *expressions* as *operands* and creates an *expression* that is *only* *true* if both operands are true
		- Both operands *MUST* be *complete expressions*
		- *NOT VALID*: temperature > 0 && < 100
		- *VALID*: temperature > 0 && temperature < 100
		- *Short circuit evaluation*: if the left side is false, the right side is ignored
		- can be used to simplify programs that would otherwise use nested if statements
	- *The \ \ operator*
		- The | | operator is known as the logical OR operator
		- takes two *expressions* as *operands* and creates an *expression* that is *only* *true* if either of the expressions are *true*
		- *Short circuit evaluation*: if the left side is true, the right side is ignored
	- *The ! operator*
		- The ! operator is known as the logical NOT operation
		- takes an operand and reverses it's truth or falsehood
		- !true = false
		- !false = true
	- *Precedence and Associativity of Logical Operators*
		- Logical Operators in order of Precedence
			- !
			- &&
			- | |
		- To avoid errors enclose the !'s operand in parentheses
- **4.10 Checking Numeric Ranges with Logical Operators**
	- *Concept*: Logical operators are effective for determining whether a number is in or out of range
	- When determining whether a number is *inside* a numeric range it is best to use *&&*
		-  if (x >= 20 && x <= 40) 
		- the expression is only true if x is in range of 20-40 inclusive
	- When determining whether a number is *outside* a numeric range it is best to use *| |*
		- if ( x < 20 | | x > 40)
		- expression is true if x is outside of range of 20-40 inclusive
- **4.11 Menus**
	- *Concept*: You can use nested *if / else* statements or the *if / else if* statement to create menu-driven programs
	- *Menu-driven programs*: #vocab 
		- a program that allows the user to select the course of action by selecting it from a list of actions
	- *Menu*: #vocab 
		- a screen displaying a set of choices from which the user selects
	- the user selects one of the operations by entering its number
	- an *if / else if* structure can be used to set up a menu
	- after a user inputs a number, the program compares the number with available choices and executes the statement that preforms that operation
- **4.12 Focus on Software Engineering: Validating User Input**
	- *Concept*: As long as the user of a program enters bad input, the program will produce bad output. Programs should be written to filter out bad input
	- "Garbage in, garbage out"
	- *Input validation*: #vocab 
		- Process of inspecting data given to a program by a user to determine if it is valid
	- A good program should give clear instructions about what kind of input is acceptable
	- don't assume the user has followed these instructions
	- EX:
		- Numbers are checked to ensure they are within range of possible values
		- Values are checked for "reasonableness". Although someone CAN work 168 hours in a week, it is not probable
		- Items selected from a menu or other sets of choices are checked to ensure they are available options
		- Variables are checked for values that might cause problems, such as division by zero
- **4.13. Comparing Characters and Strings**
	- *Concept*: Relational operators can also be used to compare characters and string objects
	- characters are stored as integers
		- 'A' is stored as 65, 'B' is 66 etc
	- every character, even the blank has an ASCII code associated with it
	- when two characters are compared, it is actually their ASCII values being compared
		- 'A' < 'B' is true for instance
	- Lowercase ASCII letters have a higher value than uppercase letters
	- *Comparing string Objects*
		- string objects van also be compared with relational operators
		- As with single characters, when two string objects are compared it is actually the ASCII values of the characters making up the strings that are being compared
		- each character is checked individually
- **4.14 The Conditional Operator**
	- *Concept*: You can use the conditional operator to create short expressions that work like *if / else* statements
	- the conditional operator is powerful unique
	- expression ? expression : expression
	- x < 0 ? y = 10 : z =20;
	- the statement above is a conditional expression and consists of three subexpressions separated by the ? and : symbols
	- equivalent to: 
	- if (x < 0)
		- y = 10;
	- else
		- z = 20
	- the part of the conditional expression that comes before the question mark is the expression to be tested.
	- the next expression is executed if the first is true
	- the final expression is executed if the first is false
	- *Using the Value of a Conditional Expression*
		- all expressions have a value
		- this includes the conditional expression
		- if the condition is true the value is the second subexpression 
		- if the condition is false the value is the third subexpression
		- hours = hours < MIN_HOURS ? MIN_HOURS : hours;
- **4.15 The _switch_ Statement**
	- *Concept*: The switch statement lets the value of a variable or an expression determine where the program will branch
	- A branch occurs when one par of a program causes another part to execute. The if / else if statements allows your program to branch into one of several possible paths
	- It performs a series of tests (usually relational) and branches when one of these tests are true
	- the *switch* statement is a similar mechanism, However it tests the value of an *integer expression* and then uses that value to determine to which set of statements to branch
	- format:
		- switch (integerExpression)
		- {
			- case ConstantExpression
				- statement
			- case ConstantExpression
				- statement
			- etc...
			- default:
				- statement
		- }
	- the first line of the statement starts with the keyword *switch* and is followed by an integer expression in parentheses:
		- a variable of any integer data type (including *char*)
		- an *expression* whose value is any *integer* data type
	- the following line is the beginning of a block containing several *case* statements
	- after the word *case*, there is a constant expression which must be an integer type
	- an optional *default* section comes after all the *case* statements
	- program branches to default if none of the *case* statements match the switch statement
	- the *break* statements show the program where to stop
	- without the *break* statements the program would execute all of the lines from the matching case statement to the end of the block
	- without the *break* statement the program "falls through" all of the statements below the one with the matching *case* expression
	- the "fall through" can also be used to branch to the same set of statements for multiple *case* expressions
		- EX: uppercase and lowercase characters 
- **4.16 The _switch_ Statement with Initialization**
	- *Concept*: Beginning with C++17, a *switch* statement can optionally have an *initialization clause*
	- with C++17 and later, you can write a switch statement with an optional initialization clause
	- format
		- switch (initialization; integerExpression)
		- {
			- case constantExpression:
				- statement(s)
			- case constantExpression:
				- statement(s)
			- default:
				  statement(s)
		- }
	- the switch initialization clause is (int value = abs(number));
		- assigns *value* to the absolute value of *number*
	- When a variable is defined in the initialization clause of a switch statement its *scope* is limited to the switch statement
- **4.17 More about Blocks and Variable Scope**
	- *Concept*: The scope of a variable is limited to the block in which it is defined
	- C++ allows you to create variables almost anywhere in a program
	- It is common practice to define all of a function's variables at the top of the function
	- Sometimes, especially in *longer programs*, it's a good idea to *define variables* near the part of the program *where they are used*
	- This makes the *purpose* of the variable *clearer*
	- The *scope* of a variable is the *part of the program* where the variable *may be used*
	- Variables defined *inside of* a *set of braces* have **local scope** or *block scope*: #vocab
		- a variable with block scope may only be used in the part of the program *between* the *variables definition* and the *closing brace* of the *block* where the *variable is defined*
	- You may define variables in any block
	- *Variables with the Same Name*
		- When a block is *nested* inside *another block*, a variable *defined* in the *inner* *block* may have the *same* *name* as a variable *defined* in the *outer* *block*
		- **HOWEVER**, the *variable* in the *outer* *block* will be *hidden*
	- example has *two* separate variables named *number*
	- the statements in the *inner block* can only work with the *number* variable defined in that block
	- as soon as the program leaves the *inner block*, that variable goes *out of scope*
	- it is best practice not to name variables the same thing

# Code Examples

```C++
#include <iostream>
using namespace std;

int main()
{
	var x = 1
	var y = 2
	
	// the condition is true, so the statement is executed
	if (x <= y)
		// conditionally executed
		cout << "x is less than or equal to y" << endl;
	
	return 0;
}
```

```C++
int main()
	//...
	
	if (average > HIGH_SCORE)
	{
		cout << "Congratulations!\n"
		cout << "That's a high score.\n"
		cout << "You deserve a pat on the back!" << endl;
	}
	
	return 0;
}
```

```c++
int main()
{
	//...
	if (num2 == 0)
	{
		cout << "Division by zero is not possible.\n"
		cout << "Please pick a different number.\n"	
	}
	else
	{
		quotient = num1/num2;
		cout << num2;
	}
	return 0;
}
```

```c++
// This program uses an if / else if statement to assign
// a letter grate to a numeric test score
#include <iostream>
using namespace std;

int main()
{
    // Constants for grade thresholds
    const int A_SCORE = 90, B_SCORE = 80, C_SCORE = 70, D_SCORE = 60;
	
    // holds numeric test score
    int testScore;
	
    cout << "Enter the numeric test score.";
    cin >> testScore;
	
    cout << "Your grade is a/an: ";
    if (testScore >= A_SCORE)
        cout << "A.\n";
    else if (testScore >= B_SCORE)
        cout << "B.\n";
	
    else if (testScore >= C_SCORE)
        cout << "C.\n";
	
    else if (testScore >= D_SCORE)
        cout << "D.\n";
	
    else if (testScore >= 0)
        cout << "F.\n";
    else
        cout << "Invalid Test Score.\n";
	
    return 0;
}
```

```c++
// This program uses the "fall through" feature of switch
#include <iostream>
using namespace std;

int main()
{
	int modelNumber;
	
	cout << "Our TVs come in three models:\n"
	cout << "The 100, 200, and 300. Which do you want? "
	cin >> modelNumber;
	
	cout << "That model has the following features:\n";
	switch (modelNumber)
	{
		case 300: cout << "\tPicture-in-picture.\n";
		case 200: cout << "\tStereo sound.\n";
		case 100: cout << "\tRemote control.\n";
				break;
		default: cout << "You can onluy choose the 100, 200, or 300.\n";
	}
	
	return 0;
}

```

```c++
// Another use of the "fall through" feature
// multiple cases select the same output
#include <iostream>
using namespace std;

int main()
{
	char feedGrade;
	
	cout << "Select what grade of pet food you want.\n";
	cout << "A, B, or C? ";
	
	cin >> feedGrade;
	
	switch (feedGrade)
	{
		case 'a':
		case 'A': cout << "$0.30 per pound.\n";
				break;
		case 'b':
		case 'B': cout << "$0.20 per pound.\n";
				break;
		case 'c':
		case 'C': cout << "$0.15 per pound.\n";
				break;
		default: cout << "That is an invalud choice.\n"
		
	}
	return 0;
}
```

```c++
switch(int vale = abs(number); value)
{
	case 1:
		cout << "one" << endl;
		break;
		
	case 2:
		cout << "two" << endl;
		break;
		
	default:
		cout << "invalid value" << endl;
}
```