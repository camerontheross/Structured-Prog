**Class**: [[CSC-121]]
**Date**: 2025-09-29
**Topics**: #functions

# Reading
- *6.1 Focus on Software Engineering: Modular Programming*
	- *Concept*: A program may be broken up into manageable functions
	- A function is a collection of statements for performing a specific task
	- *main* is a function!
	- functions are commonly used to break a problem down into smaller parts
	- One long function is bad, hard to debug
	- the process of breaking up a program into small manageable pieces is called divide and conquer
	- Breaking a problem into smaller and more manageable problems makes them *easier to solve!*
	- This also can help *simplify programs*
	- Code can be reused which saves a lot of time
- *6.2 Defining and Calling Functions*
	- *Concept*: A function call is a statement that causes a function to execute. A function definition contains the statements that make up the function
	- when creating a function you have to *define* it 
	- All *function definitions* have the following parts:
		- *Return type*: A function can send a value to the part of the program that executes it. The return type tells the computer what data type to expect
		- *Name*: You should give each function a *descriptive* name. The more descriptive the better.
		- *Parameter List*: The program can provide data to the function when the function is called. The parameter list is a list of variables that hold the values being passed to the function
		- *Body*: The body is a set of statements that perform the functions operations
	- *void functions*: #vocab 
		- functions that do not return any values
		- this usually means just performing a set of statements and then exiting
	- *Calling a function*
		- A function is executed when it is *called*
		- *main* is called automatically when a program starts
		- everything else needs to be executed with a *function call* statement
		- a function call looks like the function header without the type
		- function calls also need to be terminated with a semicolon
	- when a function terminates it branches back to the function that called it
- *6.3 Function Prototypes*
	- *Concept*: A function prototype eliminates the need to place a function definition before all calls to the function
	- before the compiler encounters a call to a particular function, it *must* already know 
		- the functions *return* *type*
		- the *type* of each parameter
	- One way of ensuring the compiler has this information is to place the function def *before* all calls to the function
	- Another way is to use a *function prototype*: #vocab 
		- A statement that declares a function
	- the prototype looks like the definition, but it is terminated with a semicolon
		- ex: void printFoo();
	- function prototypes are placed at the top of a program
	- this ensures the compiler encounters all of the functions before any calls
- *6.4 Sending Data into a Function*
	- *Concept*: When a function is called, the program may send values into the function
	- *arguments*: #vocab 
		- A *value* that is "*sent*" or *passed* to a function
	- an example of this:
		- result = pow(2.0, 4.0)
		- the double values 2.0 and 4.0 are the *arguments*
	- *parameters*: #vocab 
		- A variable that *receives* an argument that is *passed* into a function
		- ex: [[#6.4.1]]
	- a parameter's *scope* is limited to the function it is used in
	- **ARGUMENTS VS PARAMETERS**
		- *arguments* are the values *passed* to the function
		- *parameters* are the variables *receiving* the argument values	
	- by using *parameters* you can design your own functions that accept data this way!
	- when defining the *function prototype* it is *not* *necessary* to list the *name* of the *parameter* variables inside of the *parentheses*
		- void displayValue(int); // this works
	- function *arguments* can be *expressions* that result in the correct type
	- *Passing multiple arguments*
		- each parameter needs its own data type
			- void showSum(int num1, num2, num3) // does not work!
		- when a function with *multiple parameters* is called the arguments are passed to the parameters in order
- *6.5 Passing Data by Value*
	- *Concept*: When an argument is passed into a parameter, only a copy of the argument's value is passed. Changes to the parameter do *not* affect the original argument
	- *parameters* are separate and distinct from the *arguments* that are passed to them
	- The values are *copies* of the *arguments*
- *6.6 Focus on Software Engineering; Using Functions in a Menu-Driven Program*
	- *Concept*: Functions are ideal for use in menu-driven programs. When the user selects an item from a menu, the program can call the appropriate function
	- in the example we pull out the calculations and display for each respective choice
	- put logic into separate functions
- *6.7 The return Statement*
	- *Concept*: the return statement causes a function to end immediately
	- when the last statement in a void function has finished, the function terminates and returns to the statement following the function call
	- when the return function is encountered *before* the last statement the function will be forced to exit
- *6.8 Returning a Value from a Function*
	- *Concept*: A function may send a value back to the part of the program that called the function
	- set *variable* equal to a function with the *same* return *type*
	- function *must* have a valid return type
	- *void* functions do not return a value
	- a value returning function must use:
		- int, double, bool or any other valid type
	- use the desired type as the return type for the function
		- int main()
		- ^ return type is "int"
	- *local variables*: #vocab 
		- variables designed *inside* of a function
	- all value returning functions *must* return a value of the correct type
- *6.9 Returning a Boolean*
	- *Concept*: Functions may return true or false values
	- Often we need functions to test argument and return a bool
	- thats it!
- *6.10 Local and Global Variables*
	- *Concept*: A local variable is defined inside of a function and is not accessible outside the func. A global variable is defined outside of all functions and is accessible to all functions in its scope
	- *lifetime*: #vocab 
		- the time that a variable exists in memory
	- *Local Variables*
		- Variables that are defined inside of a function are local to that function
		- they area "*hidden*" from the other functions
		- some functions may even have distinct variables of the same name
		- Local variables only exist while the function executes
		- when a function *begins*, it's *local* variables and *parameter* variables are created in memory
		- When the function *ends* the *local* and *parameter* variables are *destroyed*
	- *Initializing Local Variables with Parameter Values*
		- It is possible to use a parameter variable to initialize a local variable
		- this can simplify code
		- [[#6.10.1]] vs [[#6.10.2]]
	- *Global Variables*
		- A *global variable* is any variable defined *outside* of all program functions
		- the scope of a global variable is the portion of the program from it's definition to the end
		- if a numeric global variable is not initialized, it is automatically initialized to zero
		- **globals should have restricted use**
			- *globals make debugging difficult*: Any statement can change the global variable. If you find the wrong value is being stored in a global, you have to *track* *down* which statement changed it
			- *Functions that use globals usually depend on them*: If you use one of these functions in a different program you will have to redesign it
			- *Global variables make a program hard to understand*: A global van be modified by any statement. If you are to understand any part of the program that uses a global, you have to be aware of the other parts of the program that access the global
		- Globals should be avoided
		- Declare locals and pass them instead
	- *Global Constants*
		- global constants on the other hand, are great!
		- *global constant*: #vocab 
			- a named constant that is available for every program to use
		- because the value of a constant *cannot be changed*, there is no worry of hazards and debug hell for global constants!
		- Example:
			- *suppose* a banking app uses a named constant to represent the interest rate
			- the interest rate may be needed for several functions
			- rather than having a local constant in every function, we can just initialize a global
			- if the interest rate changes, we only need to edit one value
	- *Local and Global variables with the same name*
		- You **cannot** have two local variables with the same name in the same function
		- This is the case for parameters as well
		- A parameter variable is in essence a local variable 
		- This means a local and a param cannot share a name
		- **However**, you **can** have a local or parameter share a name with a global
		- when you do, the local or parameter *shadows* #vocab the name of the global
		- This means the global variable/constant is *hidden* from the function
- *6.11 Static Local Variables*
	- If a *function* is called *more* *than* *once* in a program, the *values* stored in the local variables *do* *not* *persist* between function calls
	- basically, a function resets its local variables between function calls
	- Sometimes, we want to make the program "remember" what value is stored in a local variable
	- This can be accomplished by making the variable *static*
	- *Static local variables*: #vocab
		- a local variable that exists for the *lifetime* of the *program*
		- (rather than the lifetime of the function)
	- if you initialize a static variable, the initialization only occurs once
	- this means the value is not reset to whatever we initialize it to
- *6.12 Default Arguments*
	- *Concept*: Default arguments are passed to a parameter automatically if no argument is provided at the function call
	- it is possible to assign *default arguments* to a function parameter
	- A default argument is passed when the argument is left out
	- The default values are *usually* listed in the function *prototype*
	- parameter names are optional in the function prototype, we can also give the default variables parameter names
	- Default values are literal values or constants with an = operator in front of them
	- void showArea(double = 10.0, double = 10.0) *OR* (double length = 10.0, double width = 10.0)
	- now the arguments can be left out of the function call, and the function will use the default parameters
	- if an *argument* is *left out*, the rest of the arguments **MUST ALSO** be left out
		- cannot pass with and not length as shown above
	- because of this, we define default arguments *last* 
- *6.13 Using Reference Variables as Parameters*
	- *Concept*: When used as parameter's, reference variables allows a function to access the parameter's original argument.
	- Arguments are normally passed to a function by value
	- Function **cannot** change the *source* of the argument
	- C++ provides a special type called a *reference variable*: #vocab 
		- A variable that acts as an *alias* for another variable
		- when used as a parameter, allows access to the *original argument*
	- Any changes made to the reference variable are actually performed on the original
	- This allows the function to access and modify variables defined in other functions
	- Reference variables are defined like regular variables, but you place an *ampersand*(&) in front of their *name*
		- void doubleNum(int &refVar)
	- when prototyping, include the *&* after the type
		- void doubleNum(int &);
		- *OR* void doubleNum(int&); // no space
	- When a program works with a reference variable, it "points" to the original variable
	- only *variables* can be passed by reference, not literals, constants or expressions
	- only use these when needed!!!
- *6.14 Overloading Functions*
	- *Concept*: Two or more functions may have the same name, as long as their parameter lists are different
	- Sometimes you need to create two ore more functions that perform the same operation, but use different parameters or parameter types
	- in the example there are two square functions
	- One squares ints and the other doubles
	- in C++ each function has a signature
	- *function signature*: #vocab 
		- the name of the function, and the data types of the functions parameters in order
	- function signatures are what we use to distinguish functions of the same name
	- Overloading is also convenient for when there are similar functions that use a different number of parameters
- *6.15 The exit() function*
	- *Concept*: The exit() function causes a program to terminate, regardless of which function or control mechanism is executing
	- A C++ program stops executing when the return statement in a main function is encountered
	- When other functions end, the program does not stop
	- control goes back to the function that called the ending function
	- Rare circumstances require us to end a program in a function
	- we can use *exit();* to do this
	- it requires < cstdlib > in the header file
	- function takes an integer argument
	- This argument is the *exit code* that will be passed to the computer 
	- This code is sometimes used outside of the program to indicate if the program ended successfully, or if it crashed
- *6.16 Stubs and Drivers*
	- *Stubs* and *Drivers* are very helpful tools for testing and debugging programs with functions
	- They allow us to test the individual function in a program, in isolation  from the function calls
	- *Stub*: #vocab
		- a dummy function that is called instead of the actual function it represents
	- *Stubs* will usually display a *test message* *acknowledging* that it was *called*
	- stub example [[#6.16.1]]
	- *Driver*:
		- a program that tests a function by simply calling it
	- If the function accepts arguments, the driver displays the return value on the screen
	- This allows you to see how the function performs in isolation
	- driver example: [[#6.16.2]]

# Code examples
### 6.4.1
```c++
void displayValue(int num) // int num is a parameter
{
	cout << num << endl;
}
```

### 6.6.1
```c++
// gonna do this later
```

### 6.10.1
```c++
int sum(int num1, int num2) // the boring way to do it
{
	int result; // ew yuck
	result = num1 + num2;
	return result
}
```

### 6.10.2
```c++
int sum(int num1, int num2) // much better
{
	int result = num1 + num2; // look at how efficiant
	return result;
}
```

### 6.16.1
```c++
// example of what a stub function may look like
void showFees(double memberRate, int months)
{
	cout << "The showFees function was called with "
	<< "the following arguments: \n"
	<< "memberRate: " << memberRate << endl
	<< "months: " << months << endl;
}
```

### 6.16.2
```c++
int main()
{
	// ... membership program
	
	// Perform a test for adult membership
	cout << "Testing an adult membership."
	<< "calling the showFees function with arguments "
	<< ADULT_PRICE << " and 10.\n";
	showFees(ADULT_PRICE, 10)
	
	// other tests
}
```