**Class**: [[CSC-121]]
**Date**: 2025-09-29
**Topics**: #functions

# Reading
- *6.1 Focus on Software Engineering: Modular Programming*
	- *Concept*: A program may be broken up into manageable functions
	- A function is a collection of statements for performing a specific task
	- *main* is a function!
	- functions are commonly used to break a problem down into smaller parts
	- One long function is bad, hard to debug
	- the process of breaking up a program into small manageable pieces is called divide and conquer
	- Breaking a problem into smaller and more manageable problems makes them *easier to solve!*
	- This also can help *simplify programs*
	- Code can be reused which saves a lot of time
- *6.2 Defining and Calling Functions*
	- *Concept*: A function call is a statement that causes a function to execute. A function definition contains the statements that make up the function
	- when creating a function you have to *define* it 
	- All *function definitions* have the following parts:
		- *Return type*: A function can send a value to the part of the program that executes it. The return type tells the computer what data type to expect
		- *Name*: You should give each function a *descriptive* name. The more descriptive the better.
		- *Parameter List*: The program can provide data to the function when the function is called. The parameter list is a list of variables that hold the values being passed to the function
		- *Body*: The body is a set of statements that perform the functions operations
	- *void functions*: #vocab 
		- functions that do not return any values
		- this usually means just performing a set of statements and then exiting
	- *Calling a function*
		- A function is executed when it is *called*
		- *main* is called automatically when a program starts
		- everything else needs to be executed with a *function call* statement
		- a function call looks like the function header without the type
		- function calls also need to be terminated with a semicolon
	- when a function terminates it branches back to the function that called it
- *6.3 Function Prototypes*
	- *Concept*: A function prototype eliminates the need to place a function definition before all calls to the function
	- before the compiler encounters a call to a particular function, it *must* already know 
		- the functions *return* *type*
		- the *type* of each parameter
	- One way of ensuring the compiler has this information is to place the function def *before* all calls to the function
	- Another way is to use a *function prototype*: #vocab 
		- A statement that declares a function
	- the prototype looks like the definition, but it is terminated with a semicolon
		- ex: void printFoo();
	- function prototypes are placed at the top of a program
	- this ensures the compiler encounters all of the functions before any calls
- *6.4 Sending Data into a Function*
	- *Concept*: When a function is called, the program may send values into the function
	- *arguments*: #vocab 
		- A *value* that is "*sent*" or *passed* to a function
	- an example of this:
		- result = pow(2.0, 4.0)
		- the double values 2.0 and 4.0 are the *arguments*
	- *parameters*: #vocab 
		- A variable that *receives* an argument that is *passed* into a function
		- ex: [[#6.4.1]]
	- a parameter's *scope* is limited to the function it is used in
	- **ARGUMENTS VS PARAMETERS**
		- *arguments* are the values *passed* to the function
		- *parameters* are the variables *receiving* the argument values	
	- by using *parameters* you can design your own functions that accept data this way!
	- when defining the *function prototype* it is *not* *necessary* to list the *name* of the *parameter* variables inside of the *parentheses*
		- void displayValue(int); // this works
	- function *arguments* can be *expressions* that result in the correct type
	- *Passing multiple arguments*
		- each parameter needs its own data type
			- void showSum(int num1, num2, num3) // does not work!
		- when a function with *multiple parameters* is called the arguments are passed to the parameters in order
- *6.5 Passing Data by Value*
	- *Concept*: When an argument is passed into a parameter, only a copy of the argument's value is passed. Changes to the parameter do *not* affect the original argument
	- *parameters* are separate and distinct from the *arguments* that are passed to them
	- The values are *copies* of the *arguments*
- *6.6 Focus on Software Engineering; Using Functions in a Menu-Driven Program*
	- *Concept*: Functions are ideal for use in menu-driven programs. When the user selects an item from a menu, the program can call the appropriate function
	- in the example we pull out the calculations and display for each respective choice
	- put logic into separate functions
- *6.7 The return Statement*
	- *Concept*: the return statement causes a function to end immediately
	- when the last statement in a void function has finished, the function terminates and returns to the statement following the function call
	- when the return function is encountered *before* the last statement the function will be forced to exit
- *6.8 Returning a Value from a Function*
	- *Concept*: A function may send a value back to the part of the program that called the function
	- set *variable* equal to a function with the *same* return *type*
	- function *must* have a valid return type
	- *void* functions do not return a value
	- a value returning function must use:
		- int, double, bool or any other valid type
	- use the desired type as the return type for the function
		- int main()
		- ^ return type is "int"
	- *local variables*: #vocab 
		- variables designed *inside* of a function
	- all value returning functions *must* return a value of the correct type
- *6.9 Returning a Boolean*
- *6.10 Local and Global Variables*
- *6.11 Static Local Variables*
- *6.12 Default Arguments*
- *6.13 Using Reference Variables as Parameters*
- *6.14 Overloading Functions*
- *6.15 The exit() function*
- *6.16 Stubs and Drivers*

# Code examples
### 6.4.1
```c++
void displayValue(int num) // int num is a parameter
{
	cout << num << endl;
}
```

### 6.6.1
```c++
// gonna do this later
```