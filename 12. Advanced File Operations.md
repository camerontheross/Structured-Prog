**Class**: [[CSC-121]]
**Date**: 2025-11-10
**Topics**: #files 

# Reading

- *12.1 File Operations*
	- *Concept*: A file is a collection of data that is usually stored on a computer's disk. Data can be saved to files and then later reused
	- Ex of programs that use files (all of them lol)
		- Word Processors
		- Database Management Systems
		- Spreadsheets
		- Compilers translate source code into executables
	- *fstream* / *ofstream* (output) / *ifstream* (input) 
		- these are data types that let us work with files in C++
		- *ifstream* - Input File Stream. can be used only to *read* data from *files* into *memory*
		- *ofstream* - Output File Stream. This lets us *create* files and write *data* to them
		- *fstream* - File Stream. This lets us *create*, *write data to*, and *read data* from files
	- all require the < **fstream** > header
	- *Using the fstream Data Type*
		- [[#12.1.1]]
		- can use the *open*( ) function to open a file
		- requires *to arguments*
			- first arg is the *name of the file* (string)
			- second arg is the *file access flag*
		- the *file access flag* tells c++ how to treat the file
		- **ios::out** is used to open the file in *output mode*
			- lets us write data to the file
		- there are many other data access flags
			- **ios::app**: Append mode. If the file exists, contents are preserved and all output is *written to the end* of the file. File is created if it doesn't exist
			- **ios::ate**: If the file already exists, the program goes directly to the end of it. Output can be written in the file
			- **ios::binary**: Binary mode. When a file is opened in binary mode, data is written to or read from it in pure *binary format*. (default mode is *text*)
			- **ios::in**: Input mode. If the file *does not exist*, it *is not* created and the open function will *fail*
			- **ios::out**: Output mode. Data will be written to the file. By default, the file's contents are *overwritten* / *deleted* if the file *already exists*
			- **ios::trunc**: If the file already exists, its contents will be *deleted*(*truncated*). This is the default mode used by *ios::out*
		- these modes can be *combined* using the pipe ( **|** )
		- the very last character is the *end-of-file marker* ( < EOF > )
			- signals the end of the file to the computer
	- *Checking for a File's Existence Before Opening It*
		- This can be done by first attempting to open the file for *input*
		- [[#12.1.2]]
	- *Opening a File with the File Stream Object Definition Statement*
		- An alternative to using the open member func is to use the file stream object *definition*
		- eliminates the need to call the *open* function
		- [[#12.1.3]]
- *12.2 File Output Formatting*
	- *Concept*: File output may be formatted in the same way that screen output is formatted
	- The same way we can control how cout is formatted works with file output stream
- *12.3 Passing File Stream Objects to Functions*
	- *Concept*: File stream objects may be passed by reference to functions
	- File stream objects can be passed to functions, but the should *always* be passed by reference
- *12.4 More Detailed Error Testing* 
	- *Concept*: All stream objects have error state bits that indicate the condition of the stream
	- All stream objects have a set of bits that act as flags
		- these indicate the current state of the stream
	- **Stream Bits**
		- ![[Screenshot 2025-11-10 at 1.02.03 PM.png]]
	- **Functions to Test the State of Stream Bits**
		- ![[Screenshot 2025-11-10 at 1.02.50 PM.png]]
- *12.5 Member Functions for Reading and Writing Files*
	- *Concept*: File stream objects have member functions for more specialized file reading and writing
	- If whitespace characters are part of data in a file, the **>>** operator will cause problems
		- operator considers whitespace as *delimiters*(characters used to separate data) and does not read them
	- This can be solved by using the *getline* function
	- the function reads a *line* of data *including* whitespace
	- example of the function call: [[#12.5.1]]
		- first arg is the *name* of the *stream* object
		- second arg is the *name* of a *string* object, data will be *saved* here
		- third arg is a delimiter set by the programmer. By *default* it is set to the *newline* character
	- the statement will read from the *file stream* into the string until the *delimiter* is encountered
	- The *get* member function will *read* a *single* character from the file
	- the *put* member function *writes* a *single* character to a file
- *12.6 Focus on Software Engineering: Working with Multiple Files*
- *12.7 Binary Files* 
	- *Concept*: Binary Files contain data that is not necessarily stored as ASCII text
	- All data written and read so far has been converted and stored as ascii text
	- By using the **ios::binary** flag, data can be read and written as binary
	- data is unformatted when in binary
	- *The write and read Member functions*
		- The file stream object's *write* member function is used to write *binary* data to a file
		- function call [[#12.7.1]]
			- *fileObject* is the name of a file stream object
			- *address* is the *starting* *address* of the section of *memory* that is to be *written* to the *file*. This argument is expected to be the address of a *char* (or a pointer to a char)
			- *size* is the number of bytes of memory to write. This argument must be an integer value.
		- This will write *size* number of bytes to the file stream object
		- The *read* object works in a similar way
			- The difference is that *address* points to inside of a file
		- Both functions *read* / *write* raw binary data *to* / *from* the file
	- *Writing Data other than char to Binary files*
		- To do this, you must type cast the first argument
		- To convert a pointer from one type to another, use the *reinterpret_cast* type cast
- *12.8 Creating Records with Structures*
	- *Concept*: Structures may be used to store fixed-length records to a file.
	- *field*: #vocab 
		- An individual piece of data pertaining to a single item
	- *record*: #vocab
		- made up of fields. A complete set of data about a single item
	- **fields** may be a person's:
		- age
		- name
		- address
		- phone number
	- **records** may be a single person
	- Structures provide a convenient way to organize data into fields and records
	- [[#12..8.1]]
	- Once the *members* (or fields) are filled with data
		- we can write the *entire* variable using the *write* function
		- you have to type cast!!
	- Besides providing an organizational structure for data, structures also package data into a single unit
	- Structures containing *pointers* cannot be saved to a file since the memory for address will change
		- because *string* *class* *objects* contain *implicit* pointers, they cannot be a part of a structure that has to be stored
- *12.9 Random-Access Files*
	- *Concept*: Random access means non-sequentially accessing data in a file
	- All programs so far have had *sequential* file access
		- data is accessed line-by-line
	- The problem with this is that in order to read a *specific* piece of data, *all data before it* needs to be read first
	- C++ lets you perform *random file access*
		- this lets you jump around in a file to get specific data
	- *The **seekp** and **seekg** Member Functions*
		- Member functions of a filestream object
			- *seekp* is used with files opened for *output*
			- *seekg* is used for files opened for *input*
		- *seekp* example: [[#12.9.1]]
			- First arg is a *long* representing an *offset* into the file
				- This is the *number of* bytes that you wish to move to (from the offset)
				- *positive* will be *after*
				- *negative* is *before*
			- Second arg is *designates* where to calculate the offset from
			- in this example, the access will be 20 bytes from the file beginning (21st byte of the file)
		- *Offset Modes*
			- ![[Screenshot 2025-11-10 at 2.27.41 PM.png]]
	- *The **tellp** and **tellg** member functions*
		- Purpose is to return a *long int* representing the byte number of the current read and write position
		- These can be used to determine the number of bytes in a file
	- *Rewinding a Sequential-Access File sith seekg*
		- If a file needs to be read multiple times, you will need to reset the read position
		- you could close the file and reopen it, resetting the read position
		- you could also use *seekg* to start the reading from 0 bytes after the beginning
		- The *clear* function is used to clear the **eof** flag *before* rewinding
- *12.10 Opening a File for Both Input and Output*
	- *Concept*: You may perform input and output on an *fstream* file without closing it and reopening it
	- ios::in and ios::out can be combined together with the pipe
- *12.11 Working with the File System*
	- *Concept*: Beginning with C++17, the standard library provides numerous functions and data types that you can use to work with a computer's file system.
	- C++ lets you work with a **computer**'s *file* *system*:
		- *copy* files
		- *delete* files
		- get a *list* of files in a *directory*
		- much more!
	- < *filesystem* > is required 
	- [[#12.11.1]]
	- *Working with **path** objects*
		- Standard library includes a *path* data type
		- once defining a **path** object, you can assign it a string that contains a path
		- the *following methods* require the use of **path** objects
	- *Determining Whether a File or Directory Exists*
		- Before performing an operation on a file or dir you should *always* verify that it exists
			- file systems functions could throw an exception when attempting operations on non existent files
		- use the **exists** function to determine whether a file exists
		- pass a *path* as a parameter
	- *Copying a File* 
		- use the *copy_file* function
		- the path *from* must *exist*
		- the path *to* must *not* exist
	- *Deleting a File or Empty Directory*
		- use the *remove* function
		- If the file or directory is successfully deleted the function will return *true*
	- *Renaming a File or Directory*
		- use the *rename* function
		- *sourcePath*(first arg) contains the original name
			- this one MUST exist
		- *destinationPath* is the path of the renamed file / dir
			- if this one *exists* the file will be *overwritten* by the source path
			- this can also be used to *move* a file 
	- *Getting and Setting the Path of the CWD*
		- the get the CWD ye the *current_path* function
			- returns a *path* object
		- *current_path* can also be used to set the CWD
	- *Creating a Directory*
		- use *create_directory*
		- returns *true* if directory is created successfully
		- will return *false* if directory already exists
		- throws an exception if *parent* directories do *not* exist
	- *Deleting a Nonempty Directory*
		- *remove* does *NOT* work to delete a directory containing files
		- *remove_all* will work for this
		- returns the number of *files* or *directories* that are deleted (integer)
			- 0 if nothing is deleted / target DNE
	-  *Getting the contents of a Directory*
		- use *directory_iterator* alongside a range-based for loop
			- the range variable *entry* is a *directory_entry* object
		- *directory_entry* objects have the *path* member function, returning a path object
		- use *recursive_directory_iterator* to get the contents of subdirectories
	- *More about **directory_entry** Objects*
		- Member functions
			- *path()* - Returns a path object for the item
			- *exists()* - Returns *true* if the item exists
			- *is_regular_file()* - returns *true* if the item *exists* and is a *regular file*
			- *is_directory()* - returns *true* if the item *exists* and is a *directory*
			- *is_symlink()* - returns *true* if the item *exists* and is a *symbolic link*
				- shortcut or pointer to another file or directory
			- *is_other()* - returns *true* if the item *exists* and is not a *regular file*, *directory*, or *symbolic link*
			- *file_size()* - if the item is a *file*, returns the *size* in *bytes*. If the item is a *directory*, returns 0
	- *More about **path** Objects*
		- Member functions
			- ![[Screenshot 2025-11-11 at 1.42.52 PM.png]]
		- 

# Code Examples
### 12.1.1
```c++
fstream dataFile;

dataFile.open("words.txt", ios::out);

// opens file such that data will only be written to the end
dataFile.open("info.txt", ios::out | ios::app);
```

### 12.1.2
```c++
// test if a file already exists
fstream dataFile;
// open it in input mode
dataFile.open("values.txt", ios::in);

// input mode will fail if file DNE
if (dataFile.fail())
{
	// output mode will create a file if file DNE
	dataFile.open("values.txt", ios::out);
}
else
{
	// file already exists
	dataFile.close();
	cout << "The file values.txt already exists.\n";
}
```

### 12.1.3
```c++
// opens a file in input and output mode
fstream dataFile("names.txt", ios::in | ios::out);

// some more alternative ways to open files
ifstream inputFile("info.txt");
ofstream outputFile("addresses.txt");
ofstream dataFile("customers.txt", ios::out | ios::app;)
```

### 12.5.1
```c++
// example of a getline call on a datastream
// stream obj is datafile, saved to string str, delimiter is \n
getline(dataFile, str, '\n');
```

### 12.7.1
```c++
fileObject.write(address, size);
```

### 12..8.1
```c++
const int NAME_SIZE = 51, ADDR_SIZE = 51, PHONE_SIZE = 14;

// struct defining info of a person
// this will be a record
struct Info
{
	// these will be fields
	char name[NAME_SIZE];
	int age;
	char address1[ADDR_SIZE];
	char address2[ADDR_SIZE];
	char phone[PHONE_SIZE];
};

// create and save data on a person into a file
Info person;
// ...
// store data inside of members of person
// ...

// store person in a file
// remember to type cast!!
file.write(reinterpret_cast<char *>(&person), sizeof(person));

// read person from a file
while(!file.eof())
{
	file.read(reinterpret_cast<char *>(&person), sizeof(person));
}
file.close();
```

### 12.9.1
```c++
// example of seekp
file.seekp(20L, ios::beg);
```

### 12.11.1 
```c++
// all paths should be !!PATH OBJECTS!!

// example of exists
// works on a file or directory
// returns a bool
filesystem::exists(some_path);

// copy a file
// path FROM must exist
// path TO must NOT exist
filesystem::copy_file(pathFrom, pathTo);

// delete a file
// returns a bool
// true if path is successfully deleted
filesystem::remove(path)

// rename or move a file
filesystem::rename(sourcePath, destinationPath);

// get the CWD
filesystem::path cwd = filesytem::current_path();

// set the CWD
filesystem::current_path(path);

// create a directory
filesystem::create_directory(path);

// delete a directory with files
filesystem::delete_all(path);

// get all of the files in a directory
for (const auto &entry : filesystem::directory_iterator(path))
{
	// code here
	// print contents of directory or something
	// prank your friends by renaming all of the files or something
	// change all of your dad's files to a random string because he
	// took away your gamecube
}
```