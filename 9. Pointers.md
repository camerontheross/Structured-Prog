**Class**: [[CSC-121]]
**Date**: 2025-10-20
**Topics**: #memory #pointers #cpp

- *9.1 Getting the Address of a Variable*
	- *Concept*: The address operator (&) returns the address of a variable
	- Every variable is allocated a section of memory large enough to hold a value of the respective type
	- Each byte has an *address* in memory
	- *Address*: #vocab 
		- A number identifying a location in computer's memory
	- The variable's *address* is always the location of the *first byte* allocated
	- ![[Screenshot 2025-10-20 at 11.23.32 AM.png]]
	- Getting the address is accomplished by using the *&* operator 
	- Address-of vs Reference
		- When & is placed before a variable name in an expression is acts as *address-of*
			- *returns* the address in memory
		- When & is used in a type declaration (int&) it signifies the creation of a *reference variable*
			- acts as an *alias* for the variable, does not create new location in memory
- *9.2 Pointer Variables*
	- *Concept*: *Pointer Variables*, or *Pointers*, are designed to hold **memory** **addresses**. 
	- *Pointer Variable*: #vocab
		- A special variable that holds a memory address
	- Pointers can be used to hold the location of some other piece of data
	- "Points" to some other piece of data
	- allow you to work with whatever data they point to 
	- A *reference* variable acts as an *alias* to another variable
		- anything done to a reference effects the original variable
	- *pointers* are similar to *reference variables*, but a pointer works on the *lower level*
	- In order to make a *pointer* reference another item in memory, code has to be written to **fetch** the **memory** **address** of the item and **assign** the address to the **pointer** variable
	- also when using a pointer to store a value in memory, code has to **specify** that the value should be stored in the **memory** **location** that the pointer **references**, and not the pointer itself
	- Why are pointers even useful?
		- **Dynamic Memory Allocation**!
	- when writing a program that needs to work with an **unknown** **amount** of **data**, **dynamic** **memory** **allocation** allows you to create **variables**, **arrays** and more complex **data** **structures** in memory at **runtime**
	- Pointers are also useful in algorithms that manipulate **arrays**, and work with certain types of **strings**
	- Pointers are also useful in OOP for creating and working with objects and sharing access to those objects
	- *Creating and Using Pointers*
		- Pointer definition: [[#9.2.1]]
		- the asterisk in front of the name *indicates that the variable is a pointer*
			- asterisk can also be at the end of the type
		- int data type indicates that ptr can be used to hold the address of an integer variable
		- Pointers should **ALWAYS** be initialized with a memory address
			- Uninitialized pointers will affect an unknown address in memory if used
		- Initialize using the *nullptr* value
			- Null pointer
		- Good pointer definition: [[#9.2.2]]
		- points to nothing
		- the *real benefit* to pointers is that you can indirectly access and modify the variable being pointed to
		- *indirection operator*: #vocab 
			- asterisk before the name of the pointer
			- an operator that *dereferences* a pointer
			- lets us access and change the value stored at pointer location
		- *dereferencing*: #vocab 
			- To get the value stored at the location stored in the pointer
		- Example of indirection operator: [[#9.2.4]]
- *9.3 The Relationship between Arrays and Pointers*
	- *Concept*: Array names can be used as constant pointers, and pointers can be used as array names
	- Array names are actually pointers
	- Array names are pointer *constants*
		- cannot point to anything other than the first value of the array
	- using indirection operator gets you the first value of the array
	- to access an array element using the indirection operator you add a value to the name of the array: [[#9.3.1]]
	- adding a value to a pointer actually looks like:
		- arrayName + (value * sizeOfType)
- *9.4 Pointer Arithmetic*
	- *Concept*: Some mathematical operations may be performed on pointers
	- The contents of pointer variables may be changed with math statements that perform addition or subtraction
	- **++** or **--** can be used to increment or decrement pointer variables
	- and integer can be added or subtracted from a pointer variable (+, -, +=, -=)
	- A pointer can be subtracted from another pointer
- *9.5 Initializing Pointers*
	- *Concept*: Pointers may be initialized with the address of an existing object
	- Remember a pointer is designed to point to an object of a specific datatype
	- When a pointer is initialized with an address, it **MUST** be the address of an object the pointer can point to
		- double ptr cannot point to an int
	- pointers can be defined in the same statement as other variables of the same type
		- int myVal, * ptr = &myVal;
	- A pointer can only be initialized with the value of an object that already exists
- *9.6 Comparing Pointers*
	- *Concept*: If one address comes before another address in memory, the first address is considered "less than" the second. C++ relational operators may be used to compare pointer values
	- address of an array element 1 is greater than address of element 0
	- You can use comparison operators on these
- *9.7 Pointers as Function Parameters*
	- *Concept*: A pointer can be used as a function parameter. It gives the function access to the original argument, much like a reference pointer
	- reference variables work similarly but are much easier to work with
	- sometimes the pointer is needed so it is important to learn
	- *Pointers to Constants*
		- You need to define the pointer as a pointer to a const item
		- [[#9.7.1]]
		- In the example the array payRates is an array of *constant doubles*
		- each element in the array is a *constant double*
		- compiler will not allow us to change the contents of the array
		- when using the pointer for pay rates, a const double pointer variable is required
	- *Constant Pointers*
		- A pointer to *const* points to a constant item. The data that the pointer points to cannot change, but the pointer itself can change
		- With a *const* pointer, it is the pointer itself that is constant. Once the pointer is initialized with an address, it cannot point to anything else
		- [[#9.7.2]]
- *9.8 Dynamic Memory Allocation*
	- *Concepts*: Variables may be created and destroyed while a program is running
	- As long as you know how many variables you will need during the execution of a program, you can define those variables up front
	- A program to calculate the area of rectangle?
		- three variables
		- length, width and area
	- Payroll program for 30 employees?
		- Probably need an array of 30 elements
	- What about those times when you *don*'t know?
		- test averaging program that will average ANY number of tests
	- You allow the *program* to create its own variables *on the fly*!
	- *Dynamic memory allocation*: #vocab 
		- To reserve a chunk of memory *while* the program is *running*
	- To do this, you have to ask the computer to *set aside* a chunk of memory large enough to hold a variable of the specific *data type*
	- when the computer fills this request, it sets aside a chunk of *unused memory* large enough for the variable
	- The way this is done is with the *new* operator
	- [[#9.8.1]]
	- Theres little use to dynamically allocating a *single variable*
	- A more practical use is to dynamically create a **new** **array**
	- [[#9.8.2]]
	- *What happens when program asks for more memory than what is available?*
		- When memory can't be dynamically allocated, C++ throws an exception and terminates the program
	- When a program **finishes** using **dynamically** **allocated** chunks of **memory**, it should be **released** for future use
	- the *delete* operator is used to free memory that was allocated with *new*
	- [[#9.8.3]]
	- Failure to release dynamically allocated memory can cause a *memory leak*
	- *memory leak*: #vocab 
		- failure to release a chunk of dynamically allocated memory once the memory is no longer needed by the program
- *9.9 Returning Pointers from Functions*
	- *Concept*: Functions can return pointers but you must be sure the item the pointer references still exists
	- When writing functions that return pointers, make sure not to create elusive bugs
	- Example: [[#9.9.1]]
		- locally declared variable is returned
		- issue since locally declared variables are destroyed after end of respective function
	- You should **return** a **pointer** from a function **only** if it is:
		- A pointer to an item that was **passed** into the function as an **argument**
		- A pointer to a **dynamically allocated** chunk of memory
	- Example: [[#9.9.2]]
- *9.10 Using Smart Pointers to avoid Memory Leaks*
	- *Concept*: C++11 introduced *smart pointers*, objects that work like pointers, but have the ability to automatically delete dynamically allocated memory that is no longer being used
	- This helps prevent memory leaks
	- Modern C++ provides 3 types of smart pointer
		- **unique_ptr** - A *unique_ptr* is the sole owner of a piece of dynamically allocated memory. No two *unique_ptr*s can point to the same piece of memory. When a *unique_ptr* goes out of scope, it automatically deallocates the piece of memory it points to
		- **shared_ptr** - A *shared_ptr* can share ownership of a piece of dynamically allocated memory. Multiple pointers of the *shared_ptr* type can point to the same piece of memory. The memory is deallocated when the last *shared_ptr* that is pointing to it is destroyed
		- **weak_ptr** - A *weak_ptr* does not own the memory it points to, and cannot be used to access the memory's contents. It is used in special situations where the memory pointed to by a *shared_ptr* must be referenced without increasing the number of *shared_ptr*s  that own it
	- to use smart pointers, the < memory > header file must be included
	- unique_ptr definition syntax is a little different than regular ptr [[9.10.1]]
		- The notation < int > that appears immediately after *unique_ptr* indicates that the pointer can point to an int
		- the name of the pointer is *ptr*
		- the expression *new int* that appears inside of the parentheses allocates a chunk of memory to hold an *int*. The address of the chunk of memory will be assigned to the *ptr* pointer
	- From here, works like a regular pointer
	- smart pointer *DO NOT* support pointer arithmetic 
- *9.11 Focus on Problem Solving and Program Design: A Case Study*
	- *Concept*: This case study demonstrates how an array of pointers can be used to display the contents of a second array in sorted order, without sorting the second array
	- The United Cause, solicits donations from businesses
	- Donations are stored in order they are received (first -> last)
	- Manager asks us to display donations in ascending order as well as original order
	- *Variables needed*
		- *NUM_DONATIONS* - a *constant* *integer* initialized with the *number* of *donations* *received* from CK Graphics Inc. This value will be used in the *definition* of the *program*'s *arrays*
		- *donations* - An *array* of *integers* containing the donation amounts
		- *arrPtr* - An *array* of *pointers* to *integers*. This *array* has the same number of *elements* as the *donations* array. Each element of *arrPtr* will be initialized to *point* to an *element* of the *donations* array
	- 


### 9.2.1
```c++
// BAD definitions
int *ptr; // a pointer definition
// OR
int* ptr;
```

### 9.2.2
```c++
// GOOD def
// initialized a pointer to 0
// null pointer
int *ptr = nullptr;
```

### 9.2.3
```c++
// This program stores the address of a variable in a pointer
#include <iostream>
using namespace std;

int main()
{
	int x = 25; // int variable
	int *ptr = nullptr; // Pointer, can point to an int
	
	ptr = &x; // store the address of x in ptr
	cout << "The value in x is " << x << endl;
	cout << "The address of x is " << ptr << endl;
	
	return 0; 
}
```

### 9.2.4
```c++
// Demonstrates the use of indirection operator
#include <iostream>
using namespace std;

int main()
{
	int x = 25; // int variable
	int *ptr = nullptr; // pointer to an int
	
	ptr = &x; // store address of x
	
	// Use both x and ptr to display the value of x
	cout << x << endl;
	cout << *ptr << endl; // displays value of x
	
	// Assign to the location pointed to by ptr
	// will actually assign 100 to x
	*ptr = 100; 

	// Output value of x
	// both lines output 100
	cout << x << endl;
	cout << *ptr << endl;
	
	return 0;
}
```

### 9.3.1
```c++
// accessign 3rd array element
int arr[] = {0, 10, 4,1};
cout << arr[2] << endl; // prints 4
cout << *(arr + 2) << endl; // prints 4
```

### 9.7.1
```c++
const int SIZE = 6;
const double payRates[SIZE];  // = {...}

void displayPayRates(const double *rates, int size);
```

### 9.7.2
```c++
// defining a const pointer
int value = 22;
int * const ptr = &value;
```

### 9.8.1
```c++
int *iptr = nullptr; // define a pointer
// ask computer to set asside space for an integer
iptr = new int; // use with new operator

// ipr now contains address of newly allocated memory
// A value can now be stored by dereferencing
*iptr = 25;
```

### 9.8.2
```c++
iptr = new int[100]; // set asside space for 100 integers

// Array is created and can be accessed with subscript notation
for (int count = 0; count < 100; count++)
{
	iptr[count] = 1;
}

```

### 9.8.3
```c++
delete iptr; // delete a single variable
// if iptr points to an allocated array, use []
delete [] iptr; // delete an allocated array
```

### 9.9.1
```c++
// example of a BAD function
string *getFullName()
{
	// string array declared !!LOCALLY!!
	string fullName[3];
	
	cout << "Enter First name: ";
	getline(cin, fullName[0]);
	
	cout << "Enter Middle name: ";
	getline(cin, fullName[1]);
	
	cout << "Enter Last name: ";
	getline(cin, fullName[2]);
	
	// fullName is destroyed at the end of function
	// attempting to use a pointer to fullname will not work
	// unpredictable results
	return fullName;
}
```

### 9.9.2
```c++
// example of GOOD function
string *getFullName(string fullName[])
{
	cout "Enter your first name: ";
	getline(cin, fullName[0]);
	
	cout << "Enter Middle name: ";
	getline(cin, fullName[1]);
	
	cout << "Enter Last name: ";
	getline(cin, fullName[2]);
	
	// safe to return since fullName references a memory location
	// pointer was valid PRIOR to function call
	return fullName;

}

string *getFullName()
{
	string *fullName = new string[3];
	
	cout "Enter your first name: ";
	getline(cin, fullName[0]);
	
	cout << "Enter Middle name: ";
	getline(cin, fullName[1]);
	
	cout << "Enter Last name: ";
	getline(cin, fullName[2]);
	
	// Memory will remain allocated until DELETE used
	// safe to return this pointer
	return fullName;
}
```

### 9.10.1
```c++
// must be included to use smart pointers
#include <memory>

// ...

// unique ptr def
unique_prt<int> ptr( new int ); // defiens a unique_ptr named ptr
// points to a dynamically allocated int

// unique ptr definition
// points to a dynamically sized array of integers
const int SIZE = 100;
unique_ptr<int[]> ptr( new int [size] );

```