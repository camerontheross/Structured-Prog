# Reading
- *10.1 Character Testing*
	- *Concept*: The C++ library provides several functions for testing characters. To use these functions you must include the < cctype > headers file
	- These functions test single char arguments and return *true* or *false* 
	- ![[Screenshot 2025-10-28 at 11.19.56 AM.png]]
- *10.2 Character Case Conversion*
	- *Concept*: The C++ Library offers functions for converting a character into uppercase or lowercase
	- the *toupper* and *tolower* functions are used to do this
	- They take a character as an argument and return its *upper* or *lower* equivalent
	- if a character is passed that already meets the respective case, it will still return the upper or lower case letter
		- *toupper('Z')* returns *'Z'* 
	- These functions do not change the case stored in the variables
	- The original variable stays the same case as it was
- *10.3 C-Strings*
	- *Concept*: In C++, a C-String is a sequence of characters stored in consecutive memory, terminated by a null character
	- *String* is a generic term describing any consecutive sequence of characters
		- A word, sentence, name, song title, etc
	- C++ has two primary ways to store stings
		- *String Objects*: This is the way we have used up to now
		- *C-Strings*
	- C++ stores string literals as C-Strings
	- *More about String Literals*
		- A string literal or string constant is enclosed in a set of double quotes
		- All of a programs string literals are stored in memory as C-Strings and ended with null terminator
	- *C-Strings Stored in Arrays*
		- The C language does not provide a *string* class
		- all strings in C are C-Strings
		- Why are *C-Strings* important for learning *C++*?
			- The string class was not *always* a *feature* in C++
				- What if you need to work on *old* code?
			- Some C++ *library* functions only work with C-Strings
			- It is not uncommon to use *C libraries* with C++
				- These will all *utilize* C-Strings
		- Storing a C-String in memory requires defining a char array
		- Arrays need an *extra* space to store null terminator
		- you can easily write past the bounds of a C-string's array
		- to avoid this, use cin.getline()
- *10.4 Library Functions for Working with C-Strings*
	- *Concept*: The C++ library has numerous for handling C-strings. These functions perform various tests and manipulations, and require the < cstring > header file
	- < cstring > header required to use c-string functions
	- When using a C-string handling function you must pass one or more C-strings as arguments. You can do this by:
		- The name of the array holding the C-String
		- A pointer variable that holds the address of the C-String
		- A literal string
	- The *strlen* function
		- [[#10.4.1]]
		- determines the length of a string
		- takes a *pointer* to a c-string as an argument
		- returns length as an int
		- length represents all characters except null terminator
	- The *strcat* function 
		- [[#10.4.2]]
		- accepts two pointer to C-Strings as arguments
		- *concatenates* (appends) one string to another
	- The *strcpy* function
		- takes two c-string addresses 
		- copies second string to first
		- overwrites first string
	- These can potentially overwrite the bounds of an array
	- as an alternative use the *strncat* and *strncpy* functions
	- these work the same, however they take a third argument
	- Specifies the max number of characters that will be copied from the second string to the first
	- the *strstr* function
		- searches for a substring inside of a string
		- takes two strings as arguments
		- searches frist string for second string
		- returns address of first character if second string in found
		- null ptr if it is not found
	- the *strcmp* function
		- compares two strings
		- returns *zero* if strings are equal
		- returns *negative* if string1 comes before string2
		- returns *positive* if string1 comes after string2
		- case sensitive
	- ![[Screenshot 2025-10-28 at 3.59.01 PM.png]]
- *10.5 String / Numeric Conversion Functions*
	- *Concept*: The C++ library provides functions for converting C-strings and *string* objects to numeric data types and vice versa
	- To perform numeric operations on strings, you first have to convert it to a number
	- ![[Screenshot 2025-10-28 at 4.07.47 PM.png]]
	- C++11 introduced new functions that convert string objects to numeric values
	- ![[Screenshot 2025-10-28 at 4.08.59 PM.png]]
	- *to_string* converts a numeric value to a string
- *10.6 Focus on Software Engineering: Writing Your Own C-String Handling Functions*
- *10.7 More about the C++ **string** Class*
	- *Concept*: Standard C++ provides a special data type for storing and working with strings
	- *string* is an abstract data type
	- This means it is not a built in, primitive data type
	- It is a programmer-defined data type
	- provides many capabilities that make storing and working with strings easy
	- *Reading a line of Input into a string object*
		- if you want to read a line of input with spaces into a string object
		- use getline()
		- first arg is the name of the input stream object
		- second arg is the name of the string that stores the input
	- *Comparing and sorting string objects*
		- Using relational operators on string objects![[Screenshot 2025-10-28 at 4.19.09 PM.png]]
	- *Other ways to define string objects*
		- ![[Screenshot 2025-10-28 at 4.18.43 PM.png]]
	- *Using string class Member Functions*
		- string class has member functionss
- *10.8 Focus on Problem Solving and Program Design: A Case Study*
# Code Examples
### 10.4.1
```c++
#include <cstring> // required for using cstring functions

char name[] = "Thomas Edison";
int length;
// get the length of the 'name' char array
length = strlen(name); 
```

### 10.4.2
```c++
char string1[13] = "Hello";
char string2[] = "World";
strcat(string1, string2);
// prints "Hello World"
cout << string1 << endl;
```