- *11.1 Abstract Data Types*
	- *Concept*: Abstract data types (*ADT*s) are data types created by the programmer. ADT's have their own rage or domain of data and their own sets of operations that may be performed on them
	- *abstract data type*: #vocab
		- A data type created by the programmer
	- *abstraction*: #vocab 
		- a general model of something
	- Example
		- The term "dog" is an **abstraction**
			- defines a general type of animal
		- captures the essence of what all dogs are without listing every characteristic 
		- IRL there is no such thing as a "dog"
		- There are many kinds of dog
	- *Data Types* 
		- C++ has several *primitive* data types
		- Make up the basics of the language
		- Data types *define* what kind of value a variable can *hold*
	- *Abstract Data Types*
		- Programmer created
		- *composed* of one or more *primitive* data types
		- Programmer decides what values are *acceptable* and what *operations* can be performed on the data
			- usually designs their own special operations
- *11.2 Structures*
	- *Concept*: C++ allows you to *group* several variables together into a single item known as a *structure*
	- Imagine employee has all of these variables
		- **int** employeeNumber
		- **string** name
		- **double** hours
		- **double** payRate
		- **double** grossPay
	- Imagine storing all of that in parallel arrays
		- yeah fuck that
	- Package them together with a *structure*
	- *structure*: #vocab 
		- An abstract data type that stores a group of values together in a single variable
	- general format for a structure:
		- ![[Screenshot 2025-11-04 at 11.26.59 AM.png]]
	- [[#11.2.1]]
	- The *tag* is the name of the structure
		- used like *int* or *char*
	- The variable declarations *inside* are called *members*
	- This does not create a new variable
		- tells the compiler what the type is made of
	- After this you can use your struct as if it were any other variable type
- *11.3 Accessing Structure Members*
	- *Concept*: The *dot operator*( **.** ) allows you to access structure members in a program
	- C++ provides the dot operator to *access* the individual members of a structure
	- [[#11.3.1]]
	- Lets us use *member variables* just like regular variables
- *11.4 Initializing a Structure
	- *Concept*: The *members* of a structure variable may be *initialized* with *starting* *values* when the structure variable is *defined*
	- looks similar to how an array is initialized
	- [[#11.4.1]]
	- You do not have to provide initializers for all members
	- If you leave a member *uninitialized*, you have to leave the *following* members *uninitialized* as well
- *11.5 Arrays of Structures*
	- *Concept*: Arrays of structures can simplify programming tasks
	- Structures can replace parallel arrays
	- if this is done accessing members requires a subscript for the array
- *11.6 Focus on Software Engineering: Nested Structures*
	- *Concept*: It is possible for a structure variable to be a member of another structure variables
- *11.7 Structures as function arguments*
	- *Concept*: Structure variables may be passed as arguments to functions
	- Passed as any other variable would be
	- *Constant Reference Parameters*
		- Structures can be large, and passing them to functions can be performance heavy
		- passing by reference is useful since it does not copy the structure 
			- saves time and memory
			- problem is that the function is able to change the original values 
		- using the *const* keyword can prevent changes while providing the same advantage
- *11.8 Returning a Structure from a Function*
	- *Concept*: A function may return a structure
	- If a function returns a struct it can be assigned to any structure that shares a type
- *11.9 Using Structured Bindings with Structures*
	- *Concept*: You can use a structured binding declaration to unpack a structure and assign its member values to variables
	- Structure binding declarations can be used to *unpack* *arrays* and assign them to *variables*
	- with structs you can take the member variables and assign to new variables
	- *auto [ first, second, third ] = car;*
	- ![[Screenshot 2025-11-05 at 11.57.15 AM.png]]
- *11.10 Pointers to Structures*
	- *Concept*: You may take the address of a structure variable and create variables that are pointers to structures
	- Define similar to any other pointer
		- always start with value = to null ptr
	- accessing values is different when using a pointer
		- *dot operator* ( *.* )has a higher precedence over the *indirection operator* ( * )
	- use the *structure pointer operator* ( -> ) when accessing members of a pointer
		- automatically *dereferences* the structure pointer before accessing the value
	- *Dynamically Allocating a Structure*
		- Pointer + new operator to dynamically allocate a structure
- *11.11 Focus on Software Engineering: When to Use . or -> or ( * )*
	- ![[Screenshot 2025-11-05 at 12.08.16 PM.png]]
- *11.12 Enumerated Data Types*
	- *Concept*: An enumerated data type is a programmer-defined data type. It consists of values known as *enumerators*, which represent *integer constants*
	- [[#11.12.1]]
	- when assigning an *integer* value to an *enum* variable, it must be statically cast
	- assigning an *enum* to an *integer* works fine without type casting 
	- *Anonymous* enums can be defined for use with for loops
		- type does not have a name
		- cannot be assigned to variables 
	- *enums* can have specific values
		- Monday can be set to 1  3000 rather than 0 
	- 

# Code Examples
### 11.2.1
```c++
// a structure declaration of an Employee
struct PayRoll
{
	int employeeNumber;
	string name;
	double hours;
	double payRate;
	double grossPay;
};
// ...

// new instances of PayRoll 
PayRoll deptHead;
PayRoll foreman;
```

### 11.3.1
```c++
// using the dot operator

deptHead.employeeNumber = 475;
foreman.employeeNumber = 897;

```

### 11.4.1
```c++
// structure initialization

struct CityInfo
{
	string cityName;
	string state;
	long population;
	int distance;
};

// assigned in order
CityInfo location = {"Asheville", "NC", 80000, 28};
// does not initialize state, pops, or distance
CityInfo otherCity = {"Tampa"}; // cannot skip state to init pops or dist!!

```

### 11.12.1
```c++
// equal to 0       1        2          3       4
enum Day { MONDAY, TUESDAY, WEDNESDAY, THURDAY, FRIDAY};
// all constant values 

workday = static_cast<Day>(3); // using an integer 
// workday is THURSDAY

int x = THURSDAY; // works just fine
// x = 3
```