**Class**: [[CSC-121]]
**Date**: 2025-10-06
**Topics**: #arrays #vectors

# Reading
- *7.1 Arrays Hold Multiple Values*
	- *Concept*: An array allows you to store and work wit multiple values of the same data type
	- The variables you have worked with so far are designed to hold only one value at at time
	- *Array*: #vocab
		- A data structure that holds a group of values of the same data type
	- Example of array declaration: [[#7.1.1]]
	- *Size declarator*: #vocab 
		- an integer specifying the size of an array
	- *Element*: #vocab 
		- A value stored in an array
	- Size declarators indicate the number of elements an array can hold
	- Size declarators *must* be an *integer* that is *greater than zero*
	- it can be a *literal* or a *named constant* (*NOT* a variable)
	- Arrays of *ANY* data type can be defined
	- *Memory Requirements of Arrays*
		- The amount of memory used by an array depends on the *data type*
		- Also depends on number of elements
		- ex:
			- *short* array with *6 elements*
			- a *short* uses *2 bytes* of memory
			- with *6 elements* the array uses *12 bytes* of memory
		- size of an array is *size of type* times *number of elements*
		- ![[Screenshot 2025-10-06 at 12.54.33 PM.png]]

- *7.2 Accessing Array Elements*
	- *Concept*: The individual elements of an array are assigned unique subscripts. These subscripts are used to access the elements
	- Each element is assigned a number known as a *subscript*
	- *Subscript*: #vocab 
		- An integer value that references the location of an element in an array
	- The *first* element is assigned the value *0*
		- ascends from there
		- last element is *size* - 1
		- array with size *6* has subscripts *0-5*
	- A subscript is used as an *index* to pinpoint a specific element in the array
	- Each element can be accessed with its subscript
	- Example of *accessing* and *assigning* a value to the *first* *element* of an array: [[#7.2.1]]
	- If an *array* is defined globally, all of its *elements* are initialized to *0 by default*
	- *local arrays* have *no default initialization value*
	- *Inputting and Outputting Array Contents*
		- Array elements may be used with *cin* and *cout* objects like any other variable
	- *Stepping through an Array*
		- Even though the size declarator of an array definition *must* be a *constant or literal*, *subscript* numbers can be *stored in variables*
		- this means we can loop through arrays, performing the same operations on each element
		- Ex: [[#7.2.2]]
		- Ex [[#7.2.3]], Enter and print elements of an array
			- cout uses count + 1
			- this makes it so it displays the element as 1-5 (starts count at 1)
		- *Inputting* data in an array needs to be done one at a time
			- cin >> hours; // this does not work
		- *Outputting* also must be done one at a time
	- *Array Initialization*
		- Like regular variables, C++ lets you initialize an array's *elements* when you declare the array
		- [[#7.2.4]] 
		- *Initialization list*: #vocab 
			- a list of values, separated by commas, used to initialize an array
		- values stored in order
	- *Partial Array initialization*
		- When initializing an array, C++ does not require that every element is given a value
		- if an array is *partially initialized*, all uninitialized elements are set to 0
			- for strings they will be empty strings
		- C++ does not let you 'skip' elements
		- *Implicit Array sizing*
			- it is possible to define an array *without* a size, as long as an *initialization list* is provided
			- C++ will automatically make the array large enough to store the elements in the initialization list
	- *Working with Arrays and Files*
		- Reading contents of a file into an array is straight forward
		- Open file and use a loop to read each item from the file, storing each item into an array element
		- The loop should iterate until the array is filled, or the end of the file is reached
		- [[#7.2.5]]
	- *Writing the Contents of an Array to a File*
		- Also straightforward
		- Loop through the elements, writing contents to a file
		- [[#7.2.6]]
- *7.3 No Bounds Checking in C++*
	- *Concept*: C++ does not prevent you from overwriting an array's bounds.
	- To increase runtime, C++ does not provide many of the common safeguards found in other languages
	- C++ *does not perform bounds checking*
	- This means you can write programs with subscripts that go *beyond* the boundaries of an array
	- This will most likely cause a crash
	- *off-by-one error*: #vocab 
		- An error that occurs when a loop iterates one time too many, or one time too few while stepping through an array
- *7.4 The Range-Based for Loop*
	- *Concept*: The range-base **for** loop is a loop that iterates once for each element in an array. Each time the for loop iterates, it copies an element from the array to a variable. The range-base **for** loop was introduced in *C++ 11*
	- *range-based for loop*: #vocab 
		- A special type of loop that iterates one time per element of an array
	- You *DO NOT* need to use a counter variable to control its iterations
	- No worries about *stepping outside* of the variable's bounds
	- each loop copies an array element to the range variable 
	- it looks like:
		- for ( dataType rangeVariable : array)
			- statement or block
	- the *auto* keyword can be used in place of the data type
		- *auto* will automatically determine the data type based on the array's  data type
	- *Modifying an Array with Range-Based for loops*
		- A the rang-based for loop executes, its range variable contains a *copy* of the array element
		- As a consequence, the range-based for loop cannot modify the array contents
		- *UNLESS* you declare the range variable as a *reference*
- *7.5 Processing Array Contents*
	- *Concept*: Individual array elements are processed like any other type of variable
	- Processing array elements is no different than processing other variables
	- *Thou Shall Not Assign*
		- To copy array values to a new array, you can't just set the new array equal to the old one
		- The correct method is to *loop* through one array
		- copy the individual values to the respective index in the new array
		- This is because the name of the array (array without brackets or a subscript) is seen at the array's *beginning* memory address
		- because of this fact, trying to *assign* an array to another array looks like
			- newValues = oldValues; // what you see
			- 8012 = 8024; // what the computer sees
		- The statement will not work because you **cannot change** the starting memory address of an array
	- *Printing the Contents of an Array*
		- similarly to array assignments, you cannot just use **cout** on the entire array at once
		- to *print an array* once again you have to use a loop
		- this is also a great use of the range-based for loop
	- **Basically any operation you will want to do on an array requires a for loop**
		- getting tired of this chapter's redundancy
	- *Partially Filled Arrays*
		- sometimes you need to store a series of items in an array
		- you may not know the number of items
		- *How large do we make the array?*
		- One solution is to make the array large enough to hold the largest possible number of items
		- This can lead to another problem
			- if the *actual* number of *items* ends up being less than the number of *elements*, the array will only be partially filled
			- when processing a partially filled array, you have to make sure you only process the valid data items
		- To handle this, you can use a counter variable that keeps track of how many valid data entries are in your array
		- or just use a dynamically resizable data structure and stop being a dweeb
	- *Using Structured Binding Declarations with Arrays*
		- In some situations you may need to **retrieve** the *individual* values that are stored in an array and **assign** those values to *regular* *variables*
		- C++ 17 has a new feature known as *structured binding declarations* #feature 
		- *structured binding declarations*: #vocab 
			- A statement that *defines* a set of variables and *initializes* them with the values that are *stored* in an *array*
		- This process is known as *unpacking the array*
		- 
- *7.6 Focus on Software Engineering: Using Parallel Arrays*
	- *Concept*: By using the same subscript, you can build relationships between data stored in two or more arrays
	- Sometimes it can be useful to store related data in two or more arrays
	- *Especially* when the *related data* is of *unlike types*
	- You can do this by using the same subscript for two arrays
		- ex: two arrays for employee data. Pay rate (double) and Hours (int)
		- employee 1 has data for pay rate and hours stored in the first index for both
- *7.7 Arrays as Function Arguments*
	- *Concept*: To pass an array as an argument to a function, pass the name of the array
	- You will write many functions that will process arrays
	- They will need an array as an argument to do this
	- the array argument should look like an **array** declaration **without** a **size**
		- this is actually a **special** **variable** that accepts the **memory** **location** of the provided array
	- when calling the function, only pass the *name of the array*
	- this will pass the memory location to the function, sort of like reference variables
	- *Using **const** Array Parameters*
		- You can prevent a function from being able to make changes to an array argument
		- use the *const* keyword in the parameter declaration
		- any attempt to change the array will throw an error
- *7.8 Two-Dimensional Arrays*
	- *Concept*: A two-dimensional array is like several identical arrays put together. It is useful for storing multiple sets of data
	- A array is useful for storing and working with a set of data
	- You may need to work with *multiple* sets of data
	- Ex: grade-averaging program
		- A teacher might record **all** of one **student**'s test **scores** in an **array** of doubles
		- If the teacher has **30** **students**, that means they will need **30** **arrays** of doubles
		- instead of having 30 arrays, it is easier to have an **array** **of** **arrays**
	- *Two-dimensional arrays*: #vocab
		- An array storing data in *rows* and *columns*
	- when defining **size**, the order is *rows* then *columns*
		- [[#7.8.1]]![[Screenshot 2025-10-07 at 1.57.36 PM.png]]
	- When initializing a two dimensional array it helps to enclose each row initialization list in a set of braces
	- braces are optional but make things more *readable*
	- *Passing 2D Arrays to Functions*
		- When a 2D array is passed to a func, the parameter type **must** contain a size declarator for the number of *columns*
		- C++ requires the columns to be specifid in the function prototype bc of the way 2D arrays are stored in memory
		- One row follows another
		- When the compiler generates code for acessing the elements of a two dimensional array, it needs to know how many bytes seperate the rows in memory
		- The columns is a critical factor in this calculation
	- *Summing all the Elements of a 2D Array*
		- To sum all of the elements of a 2D array, use nested loops
	- *Summing the Rows of a 2D Array*
		- Sometimes you need to calculate the sum of each row in a 2D array
		- loop thru all elements in a row, then repeat for next row
		- the difference is setting your accumulator to zero each time
- *7.9 Arrays with Three or More Dimensions*
	- *Concept*: C++ Does not limit the number of dimensions that an array may have
	- C++ Allows you to create arrays with virtually any number of dimensions
	- Arrays with more than 3 dimensions are hard to visualize 
	- These are useful for things like tracking inventory in a warehouse
	- when passing to a function, all but the first dimension must be explicitly stated
- *7.10 Focus on Problem Solving and Program Design: A Case Study*
	- The National Commerce Bank has hired you as a contract programmer. Your first assignment is to write a **function** that will be used by the bank's automated teller machines (**ATMs**) to **validate** a customer's **PIN**. Your function will be incorporated into a larger program that asks the customer to input his or her PIN on the ATM's number pad
		- PINs are 7 digit numbers
		- The program also receives a copy of the customer's actual pin from a database 
		- The PINS are also stored in the database as 7-element arrays
		- if these numbers match, then the customer's identity is validated
	- *functions specifications*:
		- *Parameters*: The function accepts 2 *int* arrays of 7 *elements* each. The first argument will contain the number *entered* by the *customer*. The second number will be the number *received* from the *database*
		- *Return value*: The function will return a *boolean* value. *True* if the two arrays match, and *false* otherwise
	- *Pseudocode*:
		- for each element in first array
			- compare with corresponding element in second array
				- if !=
					- return false
				- end if
			- end for
		- return true
	- *Implementation*:
		- [[#7.10.1]]
- *7.11 Introduction to the STL **vector**
	- *Concept*: The standard Template Library (*STL*) offers a **vector** data type, which is in many ways, superior to the standard *array*
	- *Standard Template Library*: #vocab 
		- A collection of *Data Types* and *Algorithms* that accompany the C++ language, and can be used in a C++ program
		- These data types and algorithms are *programmer defined*
		- *NOT* part of the C++ language but were created in addition to the *built-in* data types
	- *Vector*: #vocab 
		- A data structure similar to an array, but better
	- *Vectors* are similar to *arrays*:
		- *vectors* store a sequence of values or elements
		- *vectors* store their elements in *contiguous* memory locations
		- you can use the array subscript operator [ ] to read individual elements of the vector
	- *Vectors* offer *improvements*
		- You do not have to declare the *size*
		- If you add a value to a *full* vector it will automatically *resize*
		- *vectors* can *report* the number of elements they contain
	- *Defining a vector*
		- to use vectors they must be *included*
		- defining a *vector* looks *different* than an *array*: [[#7.11.1]]
			- the data type of the elements is included in the angled brackets
		- to define a starting *size*, include *parenthesis* with the *size* at the *end* of the *name*:  [[#7.11.2]]
			- this is optional
		- when specifying a *size*, you may also specify an *initialization value*: [[#7.11.3]]
			- This initializes *all* of the *elements* to that value
		- You can *initialize* a vector with the **values** of another *vector*: [[#7.11.4]]
			- copies all of the values from one vector into the new one
		- In C++ or later you can use an **initialization** **list**, just like **arrays**
	- *Storing and Retrieving Values in a vector*
		- To store a value in an element that already exists in a vector, you may use the subscript operator [ ]
		- An error will occur if the subscript operator is given for a nonexistent value
		- This is just the same thing as Arrays
	- *Using the Range-Based for Loop with a vector in C++11*
		- with C++ 11 and later, you can use the range-based for loop to step through the elements of a vector
	- *Using the push_back Member Function*
		- when storing values in a vector *without* a *starting size*, use the **push_back** member function
		- this function accepts a value as an argument and *stores* that value *after* the last element of the vector
	- *Determining the size of a vector*
		- Unlike arrays, vectors can report their size
		- to do this, use the *size* member function
	- *Removing Elements from a vector*
		- Use the **pop_back** member function
		- this will remove the *last* element 
	- *Clearing a vector*
		- To completely clear the contents of a vector, use the **clear** member function
		- This will remove all elements
	- *Detecting an Empty vector*
		- to determine if a vector is empty, use the **empty** member function
		- this returns a boolean based on if the vector has elements or not
	- *Some of the vector member functions*:
		- **at(index)**: returns the value of the *element* located at *index*
		- **clear()**: Clears the vector of all *elements*
		- **empty()**: Checks if the vector is empty
		- **push_back(value)**: adds *value* to the end of the vector
		- **pop_back()**: removes the *last* element
		- **swap(vector2)**: swaps the contents of the vector with *vector2*
 
# Code Examples
### 7.1.1
``` C++
int days[6]; // definition of an array of integers with 6 elements
```

### 7.2.1
```C++
short hours[6]; // has subscripts 0-5
hours[0] = 20; // accesses the first element and assigns it to 20
// pronounced 'hours sub zero is assigned 20'
```

### 7.2.2
```C++
const int ARRAY_SIZE = 5;
int numbers[ARRAY_SIZE];

// loop through the array
// starts at i = 0, ends at i = 4
for (int i = 0; i < ARRAY_SIZE; i++)
{
	// access each element at i, assign it to 99
	numbers[i] = 99;
}
```

### 7.2.3
```C++
const int NUM_EMPLOYEES = 6;
int hours[NUM_EMPLOYEES];
int count;

// Input the hours worked
for (count = 0; count < NUM_EMPLOYEES; count++)
{
	cout << "Enter the hours worked by Employee "
		<< (cout + 1) << ": "; // prints 1 for element 0 for example
	cin >> hours[count];
}

// Display the array contents
cout << "The hours you entered are: "
for (count = 0; count < NUM_EMPLOYEES; count++)
{
	cout << " " << hours[count];
}
cout << endl;
```

### 7.2.4
```c++
const int MONTHS = 12;
int days[MONTHS] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

### 7.2.5
```C++
const int ARRAY_SIZE = 10;
int numbers[ARRAY_SIZE];
int count = 0;
ifstream inputFile;

inputFile.open("TenNumbers.txt");

while (count < ARRAY_SIZE && inputFIle >> numbers[count])
{
	count++;
}

inputFile.close();
```

### 7.2.6
```c++
for (count = 0; count < ARRAY_SIZE; count++)
{
	outputFile << numbers[count] << endl;
}
outputFile.close();
```

### 7.4.1
```c++
int[] numbers = { 3, 6, 9};
for (auto val : numbers)
{
	cout << val << endl;
}
```

### 7.4.2
```c++
for (auto &val : numbers)
{
	cout << "Enter an integer: ";
	cin >> val;
}
```

### 7.5.1 
```c++
// demonstrate the structured binding declaration
int testScores[] = {80, 90, 100};
auto [score1, score2, score3] = testScores; // this guy right here!
double average = (score1 + score2 + score3) / 3.0;
```

### 7.8.1
```c++
// defining a Two-Dimensional Array
double scores[3][4]; // 3 x 4 array

```

### 7.8.2
```c++
// initializing a 2D array
int hours[3][2] = {{8, 9}, {7,9}, {6,3}};
// or like this
int hours[3][2] = {{8, 9},
				   {7,9},
				   {6,3}};
```

### 7.10.1
```c++
// compares two bank PINs and returns if they are equal
bool testPIn(const int customerPIN[], const int databasePIN[], int size)
{
	for (int index = 0; index < size; index++)
	{
		if (customerPin[index] != databasePIN[index])
			return false; // returns as soon as the first difference found
	}
	return true; // only runs once we exit the for loop (check all numbers)
}
```

### 7.11.1
```c++
// defining a vector of integers called numbers
vector<int> numbers;
```

### 7.11.2
```c++
// defining a vector with (optional) size of 10
vector<int> numbers(10);
```

### 7.11.3
``` c++
// defining a vector with size and initial value of 2
vector<int> numbers(10, 2); // vector is now 10 elements, all set to 2
```

### 7.11.4
```c++
vector<int> set2(set1); // copies all values from set1 into set 2
```