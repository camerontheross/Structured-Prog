**Class**: [[CSC-121]]
**Date**: 2025-10-06
**Topics**: #arrays #vectors

# Reading
- *7.1 Arrays Hold Multiple Values*
	- *Concept*: An array allows you to store and work wit multiple values of the same data type
	- The variables you have worked with so far are designed to hold only one value at at time
	- *Array*: #vocab
		- A data structure that holds a group of values of the same data type
	- Example of array declaration: [[#7.1.1]]
	- *Size declarator*: #vocab 
		- an integer specifying the size of an array
	- *Element*: #vocab 
		- A value stored in an array
	- Size declarators indicate the number of elements an array can hold
	- Size declarators *must* be an *integer* that is *greater than zero*
	- it can be a *literal* or a *named constant* (*NOT* a variable)
	- Arrays of *ANY* data type can be defined
	- *Memory Requirements of Arrays*
		- The amount of memory used by an array depends on the *data type*
		- Also depends on number of elements
		- ex:
			- *short* array with *6 elements*
			- a *short* uses *2 bytes* of memory
			- with *6 elements* the array uses *12 bytes* of memory
		- size of an array is *size of type* times *number of elements*
		- ![[Screenshot 2025-10-06 at 12.54.33 PM.png]]

- *7.2 Accessing Array Elements*
	- *Concept*: The individual elements of an array are assigned unique subscripts. These subscripts are used to access the elements
	- Each element is assigned a number known as a *subscript*
	- *Subscript*: #vocab 
		- An integer value that references the location of an element in an array
	- The *first* element is assigned the value *0*
		- ascends from there
		- last element is *size* - 1
		- array with size *6* has subscripts *0-5*
	- A subscript is used as an *index* to pinpoint a specific element in the array
	- Each element can be accessed with its subscript
	- Example of *accessing* and *assigning* a value to the *first* *element* of an array: [[#7.2.1]]
	- If an *array* is defined globally, all of its *elements* are initialized to *0 by default*
	- *local arrays* have *no default initialization value*
	- *Inputting and Outputting Array Contents*
		- Array elements may be used with *cin* and *cout* objects like any other variable
	- *Stepping through an Array*
		- Even though the size declarator of an array definition *must* be a *constant or literal*, *subscript* numbers can be *stored in variables*
		- this means we can loop through arrays, performing the same operations on each element
		- Ex: [[#7.2.2]]
		- Ex [[#7.2.3]], Enter and print elements of an array
			- cout uses count + 1
			- this makes it so it displays the element as 1-5 (starts count at 1)
		- *Inputting* data in an array needs to be done one at a time
			- cin >> hours; // this does not work
		- *Outputting* also must be done one at a time
	- *Array Initialization*
		- Like regular variables, C++ lets you initialize an array's *elements* when you declare the array
		- [[#7.2.4]] 
		- *Initialization list*: #vocab 
			- a list of values, separated by commas, used to initialize an array
		- values stored in order
	- *Partial Array initialization*
		- When initializing an array, C++ does not require that every element is given a value
		- if an array is *partially initialized*, all uninitialized elements are set to 0
			- for strings they will be empty strings
		- C++ does not let you 'skip' elements
		- *Implicit Array sizing*
			- it is possible to define an array *without* a size, as long as an *initialization list* is provided
			- C++ will automatically make the array large enough to store the elements in the initialization list
	- *Working with Arrays and Files*
		- Reading contents of a file into an array is straight forward
		- Open file and use a loop to read each item from the file, storing each item into an array element
		- The loop should iterate until the array is filled, or the end of the file is reached
		- [[#7.2.5]]
	- *Writing the Contents of an Array to a File*
		- Also straightforward
		- Loop through the elements, writing contents to a file
		- [[#7.2.6]]
- *7.3 No Bounds Checking in C++*
	- *Concept*: C++ does not prevent you from overwriting an array's bounds.
	- To increase runtime, C++ does not provide many of the common safeguards found in other languages
	- C++ *does not perform bounds checking*
	- This means you can write programs with subscripts that go *beyond* the boundaries of an array
	- This will most likely cause a crash
	- *off-by-one error*: #vocab 
		- An error that occurs when a loop iterates one time too many, or one time too few while stepping through an array
- *7.4 The Range-Based for Loop*
	- *Concept*: The range-base **for** loop is a loop that iterates once for each element in an array. Each time the for loop iterates, it copies an element from the array to a variable. The range-base **for** loop was introduced in *C++ 11*
	- *range-based for loop*: #vocab 
		- A special type of loop that iterates one time per element of an array
	- You *DO NOT* need to use a counter variable to control its iterations
	- No worries about *stepping outside* of the variable's bounds
	- each loop copies an array element to the range variable 
	- it looks like:
		- for ( dataType rangeVariable : array)
			- statement or block
	- the *auto* keyword can be used in place of the data type
		- *auto* will automatically determine the data type based on the array's  data type
	- *Modifying an Array with Range-Based for loops*
		- A the rang-based for loop executes, its range variable contains a *copy* of the array element
		- As a consequence, the range-based for loop cannot modify the array contents
		- *UNLESS* you declare the range variable as a *reference*
- *7.5 Processing Array Contents*
	- *Concept*: Individual array elements are processed like any other type of variable
	- Processing array elements is no different than processing other variables
	- *Thou Shall Not Assign*
		- To copy array values to a new array, you can't just set the new array equal to the old one
		- The correct method is to *loop* through one array
		- copy the individual values to the respective index in the new array
		- This is because the name of the array (array without brackets or a subscript) is seen at the array's *beginning* memory address
		- because of this fact, trying to *assign* an array to another array looks like
			- newValues = oldValues; // what you see
			- 8012 = 8024; // what the computer sees
		- The statement will not work because you **cannot change** the starting memory address of an array
	- *Printing the Contents of an Array*
		- similarly to array assignments, you cannot just use **cout** on the entire array at once
		- to *print an array* once again you have to use a loop
		- this is also a great use of the range-based for loop
	- **Basically any operation you will want to do on an array requires a for loop**
		- getting tired of this chapter's redundancy
	- *Partially Filled Arrays*
		- sometimes you need to store a series of items in an array
		- you may not know the number of items
		- *How large do we make the array?*
		- One solution is to make the array large enough to hold the largest possible number of items
		- This can lead to another problem
			- if the *actual* number of *items* ends up being less than the number of *elements*, the array will only be partially filled
			- when processing a partially filled array, you have to make sure you only process the valid data items
		- To handle this, you can use a counter variable that keeps track of how many valid data entries are in your array
		- or just use a dynamically resizable data structure and stop being a dweeb
	- *Using Structured Binding Declarations with Arrays*
		- In some situations you may need to **retrieve** the *individual* values that are stored in an array and **assign** those values to *regular* *variables*
		- C++ 17 has a new feature known as *structured binding declarations* #feature 
		- *structured binding declarations*: #vocab 
			- A statement that *defines* a set of variables and *initializes* them with the values that are *stored* in an *array*
		- This process is known as *unpacking the array*
		- 
- *7.6 Focus on Software Engineering: Using Parallel Arrays*
	- *Concept*: By using the same subscript, you can build relationships between data stored in two or more arrays
	- Sometimes it can be useful to store related data in two or more arrays
	- *Especially* when the *related data* is of *unlike types*
	- You can do this by using the same subscript for two arrays
		- ex: two arrays for employee data. Pay rate (double) and Hours (int)
		- employee 1 has data for pay rate and hours stored in the first index for both
- *7.7 Arrays as Function Arguments*
	- *Concept*: To pass an array as an argument to a function, pass the name of the array
	- You will write many functions that will process arrays
	- They will need an array as an argument to do this
	- the array argument should look like an **array** declaration **without** a **size**
		- this is actually a **special** **variable** that accepts the **memory** **location** of the provided array
	- when calling the function, only pass the *name of the array*
	- this will pass the memory location to the function, sort of like reference variables
	- *Using **const** Array Parameters*
		- You can prevent a function from being able to make changes to an array argument
		- use the *const* keyword in the parameter declaration
		- any attempt to change the array will throw an error
- *7.8 Two-Dimensional Arrays*
	- *Concept*: A two-dimensional array is like several identical arrays put together. It is useful for storing multiple sets of data
	- A array is useful for storing and working with a set of data
	- You may need to work with *multiple* sets of data
	- Ex: grade-averaging program
		- A teacher might record **all** of one **student**'s test **scores** in an **array** of doubles
		- If the teacher has **30** **students**, that means they will need **30** **arrays** of doubles
		- instead of having 30 arrays, it is easier to have an **array** **of** **arrays**
	- *Two-dimensional arrays*: #vocab
		- An array storing data in *rows* and *columns*
	- when defining **size**, the order is *rows* then *columns*
		- [[#7.8.1]]![[Screenshot 2025-10-07 at 1.57.36 PM.png]]
	- When initializing a two dimensional array it helps to enclose each row initialization list in a set of braces
	- braces are optional but make things more *readable*
	- *Passing 2D Arrays to Functions*
		- When a 2D array is passed to a func, the parameter type **must** contain a size declarator for the number of *columns*
		- 
- *7.9 Arrays with Three or More Dimensions*
- *7.10 Focus on Problem Solving and Program Design: A Case Study*
- *7.11 Introduction to the STL **vector**

# Code Examples
### 7.1.1
``` C++
int days[6]; // definition of an array of integers with 6 elements
```

### 7.2.1
```C++
short hours[6]; // has subscripts 0-5
hours[0] = 20; // accesses the first element and assigns it to 20
// pronounced 'hours sub zero is assigned 20'
```

### 7.2.2
```C++
const int ARRAY_SIZE = 5;
int numbers[ARRAY_SIZE];

// loop through the array
// starts at i = 0, ends at i = 4
for (int i = 0; i < ARRAY_SIZE; i++)
{
	// access each element at i, assign it to 99
	numbers[i] = 99;
}
```

### 7.2.3
```C++
const int NUM_EMPLOYEES = 6;
int hours[NUM_EMPLOYEES];
int count;

// Input the hours worked
for (count = 0; count < NUM_EMPLOYEES; count++)
{
	cout << "Enter the hours worked by Employee "
		<< (cout + 1) << ": "; // prints 1 for element 0 for example
	cin >> hours[count];
}

// Display the array contents
cout << "The hours you entered are: "
for (count = 0; count < NUM_EMPLOYEES; count++)
{
	cout << " " << hours[count];
}
cout << endl;
```

### 7.2.4
```c++
const int MONTHS = 12;
int days[MONTHS] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

### 7.2.5
```C++
const int ARRAY_SIZE = 10;
int numbers[ARRAY_SIZE];
int count = 0;
ifstream inputFile;

inputFile.open("TenNumbers.txt");

while (count < ARRAY_SIZE && inputFIle >> numbers[count])
{
	count++;
}

inputFile.close();
```

### 7.2.6
```c++
for (count = 0; count < ARRAY_SIZE; count++)
{
	outputFile << numbers[count] << endl;
}
outputFile.close();
```

### 7.4.1
```c++
int[] numbers = { 3, 6, 9};
for (auto val : numbers)
{
	cout << val << endl;
}
```

### 7.4.2
```c++
for (auto &val : numbers)
{
	cout << "Enter an integer: ";
	cin >> val;
}
```

### 7.5.1 
```c++
// demonstrate the structured binding declaration
int testScores[] = {80, 90, 100};
auto [score1, score2, score3] = testScores; // this guy right here!
double average = (score1 + score2 + score3) / 3.0;
```

### 7.8.1
```c++
// defining a Two-Dimensional Array
double scores[3][4]; // 3 x 4 array

```

### 7.8.2
```c++
// initializing a 2D array
int hours[3][2] = {{8, 9}, {7,9}, {6,3}};
// or like this
int hours[3][2] = {{8, 9},
				   {7,9},
				   {6,3}};
```